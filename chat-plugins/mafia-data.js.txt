'use strict';
/** @typedef {{name: string, plural: string, id: string, color?: string, buttonColor?: string, memo: string[], image?: string}} MafiaAlignment */
/** @typedef {{[k: string]: MafiaAlignment | string}} MafiaAlignments */

/** @typedef {{name: string, id: string, memo: string[], alignment?: string, image?: string}} MafiaRole */
/** @typedef {{[k: string]: MafiaRole | string}} MafiaRoles */

/** @typedef {{name: string, id: string, memo: string[]}} MafiaModifier */
/** @typedef {{[k: string]: MafiaModifier | string}} MafiaModifiers */

/** @typedef {{name: string, desc: string, [k: number]: string}} MafiaTheme */
/** @typedef {{[k: string]: MafiaTheme | string}} MafiaThemes */

/** @typedef {{name: string, roles: string[], picks: string[], choices: number}} MafiaIDEA */
/** @typedef {{[k: string]: MafiaIDEA | string}} MafiaIDEAs */

/** @type {MafiaAlignments} */
const alignments = {
	//  Do not add Mafia variants, unless they are supported in a major theme (Werewolves, Replicants).
	//  Do not add Solo alignments.
	town: {
		name: `Town`,
		plural: `Town`,
		id: `town`,
		color: `#060`,
		buttonColor: `#0A0`,
		memo: [`You are aligned with the <span style="color:#060;font-weight:bold">Town</span>. You win when all threats to the Town are eliminated and at least one Town-aligned player is still alive, or nothing can prevent the same.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	mafia: {
		name: `Mafia`,
		plural: `Mafia`,
		id: `mafia`,
		color: `#F00`,
		memo: [
			`Factional Communication: If there are other Mafia-aligned players, you may PM them during the game.`,
			`Factional Kill: The Mafia may kill one player per night.`,
			`You are aligned with the <span style="color:#F00;font-weight:bold">Mafia</span>. You win when all players without a Mafia wincon are eliminated and at least one Mafia-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-mafia.png"/>`,
	},
	werewolf: {
		name: `Werewolf`,
		plural: `Werewolves`,
		id: `werewolf`,
		color: `#FFA500`,
		memo: [
			`Factional Communication: If there are other Werewolf-aligned players, you may PM them during the game.`,
			`Factional Kill: The Werewolves may kill one player per Night.`,
			`You are aligned with the <span style="color:#FFA500;font-weight:bold">Werewolves</span>. You win when all players without a Werewolf wincon are eliminated and at least one Werewolf-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-werewolf.png"/>`,
	},
	alien: {
		name: `Alien`,
		plural: `Aliens`,
		id: `alien`,
		color: `#F0F`,
		memo: [
			`Factional Communication: If there are other Alien-aligned players, you may PM them during the game.`,
			`Factional Kill: The Aliens may kill one player <span style="text-decoration:underline">once during the game</span>.`,
			`You are aligned with the <span style="color:#F0F;font-weight:bold">Aliens</span>. You win when all players without a Alien wincon are eliminated and at least one Alien-aligned player is still alive (or nothing can prevent the same).`,
		],
		// TODO image for alien faction
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	cult: {
		name: `Cult`,
		plural: `Cultists`,
		id: `cult`,
		color: `#000`,
		memo: [
			`Factional Communication: If there are other Cult-aligned players, you may PM them during the game.`,
			`Factional Concept: The Cult can recruit other players into the Cult more often than not. Ask the Host for more information about how this works exactly.`,
			`You are aligned with the <span style="color:#000;font-weight:bold">Cult</span>. You win when all players without a Cult wincon are eliminated and at least one Cult-aligned player is still alive (or nothing can prevent the same).`,
		],
		// TODO image for cult faction
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	cultafia: {
		name: `Cultafia`,
		plural: `Cultafia`,
		id: `cultafia`,
		color: `#600`,
		memo: [
			`Factional Communication: If there are other Cultafia-aligned players, you may PM them during the game.`,
			`Factional Concept: The Cultafia can recruit and kill players. Ask the Host for more information about how this works exactly.`,
			`You are aligned with the <span style="color:#600;font-weight:bold">Cultafia</span>. You win when all players without a Cultafia wincon are eliminated and at least one Cultafia-aligned player is still alive (or nothing can prevent the same).`,
		],
		// TODO image for cult faction
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	goo: {
		name: `Goo`,
		plural: `Goos`,
		id: `goo`,
		color: `#2FF`,
		memo: [
			`Factional Communication: If there are other Goo-aligned players, you may PM them during the game.`,
			`Factional Concept: Goos have interesting Reflexive abilities to aid them more often than not.`,
			`You are aligned with the <span style="color:#2FF;font-weight:bold">Goos</span>. You win when all players without a Goo wincon are eliminated and at least one Goo-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	replicant: {
		name: `Replicant`,
		plural: `Replicants`,
		id: `replicant`,
		color: `#DDD`,
		memo: [
			`Factional Communication: If there are other Replicant-aligned players, you may PM them during the game.`,
			`Factional Kill: The Replicants may kill one player per night.`,
			`You are aligned with the <span style="color:#DDD;font-weight:bold">Replicants</span>. You win when all players without a Replicant wincon are eliminated and at least one Replicant-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	mime: {
		name: `Mime`,
		plural: `Mimes`,
		id: `mime`,
		color: `#A6B`,
		memo: [
			`Factional Communication: If there are other Mime-aligned players, you may PM them during the game.`,
			`Factional Roleblock: The Mimes may roleblock one player per night.`,
			`You are aligned with the <span style="color:#A6B;font-weight:bold">Mimes</span>. You win when all players with a Mime wincon have been lynched.`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	arsonist: {
		name: `Arsonist`,
		plural: `Arsonists`,
		id: `arsonist`,
		color: `#E82`,
		memo: [
			`Factional Communication: If there are other Arsonist-aligned players, you may PM them during the game.`,
			`Factional Actions: The Arsonists may together use one factional action a night.`,
			`Factional Prime: The Arsonists prime someone by dousing them with gasoline.`,
			`Factional Ignite: The Arsonists light all previously primed players on fire, killing them.`,
			`You are aligned with the <span style="color:#E82;font-weight:bold">Arsonists</span>. You win when all players without an Arsonist wincon are eliminated and at least one Arsonist-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	pygmee: {
		name: `Pygmee`,
		plural: `Pygmees`,
		id: `pygmee`,
		color: `#640`,
		memo: [
			`Factional Knowledge: If there are other Pygmee-aligned players, you know who they are.`,
			`Factional Kill: The Pygmees may attempt to kill someone at any moment.`,
			`You are aligned with the <span style="color:#640;font-weight:bold">Pygmees</span>. You win when all players without a Pygmee wincon are eliminated and at least one Pygmee-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	// Will be added in SI soon.
	hypnotist: {
		name: `Hypnotist`,
		plural: `Hypnotists`,
		id: `hypnotist`,
		color: `#A26`,
		memo: [
			`Factional Communication: If there are other Hypnotist-aligned players, you may PM them during the game.`,
			`Factional Hypnotise: The Hypnotists can hypnotise another player every night. For the next day only, this player gains an additional win-condition of lynching another player specified by the Hypnotists.`,
			`You are aligned with the <span style="color:#A26;font-weight:bold">Hypnotists</span>. You win when all players without a Hypnotist wincon are eliminated and at least one Hypnotist-aligned player is still alive (or nothing can prevent the same).`,
		],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
	},
	solo: {
		// Special alignment for all roles that are on their own.
		name: `Solo`,
		plural: `Solos`,
		id: `solo`,
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-goon.png"/>`,
		memo: [],
	},
};

/** @type {MafiaRoles} */
const roles = {
	// active abilities and alignment indicating abilities
	vt: `villager`,
	vanilla_townie: `villager`,
	vanillager: `villager`,
	villy: `villager`,
	townie: `villager`,
	villager: {
		name: `Villager`,
		id: `villager`,
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`,
		memo: [`Vanilla Townie: Town player without any additional abilities.`],
	},
	goon: {
		name: `Goon`,
		id: `goon`,
		memo: [`Goon: Mafia player without any additional abilities.`],
	},
	assassin: {
		name: `Assassin`,
		id: `assassin`,
		memo: [`Assassin (Assassin in the Court): Wins when the King dies. Can shoot another player publicly once a game, but loses if this wasn't the King.`],
	},
	baby_monarch: {
		name: `Baby Monarch`,
		id: `babymonarch`,
		memo: [`Baby Monarch: Turns into a Monarch at the start of Day 4. It is announced that someone has turned into a Monarch.`],
	},
	babysitter: {
		name: `Babysitter`,
		id: `babysitter`,
		memo: [`Babysitter: During the Night, you may PM the host the name of another player. This player will be protected from all nightkills for that Night, but if the Babysitter dies, its target will die too.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-doctor.png"/>`,
	},
	black_goo: {
		name: `Black Goo`,
		id: `blackgoo`,
		alignment: `town`,
		memo: [`Black Goo: Anyone who targets you will join the Cult.`],
	},
	blacksmith: {
		name: `Blacksmith`,
		id: `blacksmith`,
		memo: [`Blacksmith: During the Day, you may PM the host the name of another player. This player will be protected from one kill that day.`],
	},
	bh: `bloodhound`,
	bloodhound: {
		name: `Bloodhound`,
		id: `bloodhound`,
		memo: [`Bloodhound: Each night you can PM the host the name of another player. You will be told if they are TOWN or NOT TOWN, or receive NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	bloodsucker: {
		name: `Bloodsucker`,
		id: `bloodsucker`,
		memo: [`Bloodsucker: Each night you can PM the host the name of another player. This player will die and become a Treestump.`],
	},
	bg: `bodyguard`,
	bodyguard: {
		name: `Bodyguard`,
		id: `bodyguard`,
		memo: [`Bodyguard: During the Night, you may PM the host the name of another player. This player will be protected from all nightkills for that Night, but the Bodyguard will be killed instead.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-doctor.png"/>`,
	},
	busdriver: {
		name: `Bus Driver`,
		id: `busdriver`,
		memo: [`Bus Driver: During the Night, you may PM the host the names of the two players. People who targeted either of these players will instead target the other one.`],
	},
	chameleon_goo: {
		name: `Chameleon Goo`,
		id: `chameleongoo`,
		alignment: `goo`,
		memo: [`Chameleon Goo: Anyone who targets you will join the Cult. You are a Mason, and will die after Night 2. There is no way to stop this death.`],
	},
	commuter: {
		name: `Commuter`,
		id: `commuter`,
		memo: [`Commuter: During the Night, you may PM the host that you want to commute. No other player will be able to target you this night.`],
	},
	conspiracy_theorist: {
		name: `Conspiracy Theorist`,
		id: `conspiracytheorist`,
		memo: [`Conspiracy Theorist: Each night you can PM the host the name of another player. You will be told if they are ALIEN or NOT ALIEN, or receive NO RESULT if your investigation failed. Additionally, you will always be inspected as an ALIEN when possible.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	// Above cop so it gets checked first
	role_cop: {
		name: `Role Cop`,
		id: `rolecop`,
		memo: [`Role Cop: Each night you can PM the host the name of another player. You will be told their exact role, or NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	cop: {
		name: `Cop`,
		id: `cop`,
		memo: [`Cop: Each night you can PM the host the name of another player. You will be told if they are MAFIA or NOT MAFIA, or receive NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	coat: `cop-of-all-trades`,
	cop_of_all_trades: `cop-of-all-trades`,
	'cop-of-all-trades': {
		name: `Cop-of-all-Trades`,
		id: `copofalltrades`,
		memo: [`Cop-of-all-Trades: You may use the actions of a Cop, a Seer, an FBI Agent, a Conspiracy Theorist, and a Private Investigator once a game each.`],
	},
	coroner: `coronereternalsun`,
	coroneresun: `coronereternalsun`,
	coroner_esun: `coronereternalsun`,
	coroner_eternal_sun: `coronereternalsun`,
	coronereternalsun: {
		name: `Coroner (Eternal Sun)`,
		id: `coronereternalsun`,
		memo: [`Coroner: When any player dies, you will be PMd which role they were. Note: Check 'Coroner CI' for information about Coroners in Cracking Idea.`],
	},
	coroner_ci: `coronercrackingidea`,
	coronerci: `coronercrackingidea`,
	coroner_cracking_idea: `coronercrackingidea`,
	coronercrackingidea: {
		name: `Coroner (Cracking Idea)`,
		id: `coronercrackingidea`,
		memo: [`Coroner: Each night you can PM the host the name of another (dead) player. You learn the role(s) of the player who killed them, but not who this role belongs to. This also works when your target dies the night you used it.`],
	},
	cupid: {
		name: `Cupid`,
		id: `cupid`,
		memo: [`Cupid: At Night One you can PM the host the name of another player. Every other player who targeted the target becomes Lovers with the target.`],
	},
	desperado: {
		name: `Desperado`,
		id: `desperado`,
		memo: [`Desperado: At Night, you can PM the host the name of another player. You will kill this player if they're not aligned with the TOWN, but you will die if they are.`],
	},
	doc: `doctor`,
	doctor: {
		name: `Doctor`,
		id: `doctor`,
		memo: [`Doctor: During the Night, you may PM the host the name of another player. This player will be protected from all nightkills for that Night.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-doctor.png"/>`,
	},
	drookez: {
		name: `Drookez`,
		id: `drookez`,
		memo: [`Drookez: You are a Deathproof Mafia's Child Lover. This means that your role is revealed at the start of the game and that you can't die unless your Lover dies.`],
	},
	fbi_agent: {
		name: `FBI Agent`,
		id: `fbiagent`,
		memo: [`FBI Agent: Each night you can PM the host the name of another player. You will be told if they are SERIAL KILLER or NOT SERIAL KILLER, or receive NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	firefighter: {
		name: `Firefighter`,
		id: `firefighter`,
		memo: [`Firefighter: During the Night, you may PM the host the name of another player. This player can't be primed by an Arsonist that night.`],
	},
	fruit_vendor: {
		name: `Fruit Vendor`,
		id: `fruitvendor`,
		memo: [`Fruit Vendor: During the Night, you may PM the host the name of another player. This player will receive fruit.`],
	},
	gladiator: {
		name: `Gladiator`,
		id: `gladiator`,
		memo: [`Gladiator: During the Night, you may PM the host the names of two players. These two players will be the only two who can be lynched the next day, assuming both of them are alive at the end of the night.`],
	},
	goomaker: {
		name: `Goomaker`,
		id: `goomaker`,
		memo: [`Goomaker: During the Night, you may PM the host the name of another player. This player will take on the Black Goo ability.`],
	},
	governor: {
		name: `Governor`,
		id: `governor`,
		memo: [`Governor: At the end of each day, the Governor can decide whether the person who would be lynched will die or not.`],
	},
	gray_goo: {
		name: `Gray Goo`,
		id: `graygoo`,
		alignment: `goo`,
		memo: [`Gray Goo: Anyone who targets you will join the Cult. You will die after Night 2. There is no way to stop this death.`],
	},
	guard: {
		name: `Guard`,
		id: `guard`,
		memo: [`Guard (Assassin in the Court): You get to know the identity of the King at the start of the game.`],
	},
	gunsmith: {
		name: `Gunsmith`,
		id: `gunsmith`,
		memo: [`Gunsmith: Once per day or night, you can PM the name of a player to the host. This player will receive a gun, which they can kill someone with that day (if given at day) or the next day (if given at night).`],
	},
	hider: {
		name: `Hider`,
		id: `hider`,
		memo: [`Hider: During the Night, you may PM the host the name of another player. You will not be able to be targeted that night, but if the person you targeted died or is not aligned with the TOWN, you die.`],
	},
	innocent_child: {
		name: `Innocent Child`,
		id: `innocentchild`,
		memo: [`Innocent Child: At any point during the game, you may PM the host to reveal you as TOWN publicly.`],
	},
	joat: `jack-of-all-trades`,
	jack_of_all_trades: `jack-of-all-trades`,
	'jack-of-all-trades': {
		name: `Jack-of-all-Trades`,
		id: `jackofalltrades`,
		memo: [`Jack-of-all-Trades: You may use the actions of a Cop, a Roleblocker, and a Doctor once a game each.`],
	},
	jk: `jailkeeper`,
	jailkeeper: {
		name: `Jailkeeper`,
		id: `jailkeeper`,
		memo: [`Jailkeeper: During the Night, you may PM the host the name of another player. This player will be protected from all nightkills for that Night and won't be able to use an action that Night.`],
	},
	janitor: {
		name: `Janitor`,
		id: `janitor`,
		memo: [`Janitor: Whenever a player dies, the Janitor can decide whether or not their role gets revealed.`],
	},
	jester: {
		name: `Jester`,
		id: `jester`,
		memo: [`Jester: You are aligned with yourself. You win if you get lynched at any point during the game.`],
	},
	journalist: {
		name: `Journalist`,
		id: `journalist`,
		memo: [`Journalist: Each night, you can PM the host the name of a player. When you die, all players you inspected will be publicly revealed as TOWN or NOT TOWN.`],
	},
	judas: {
		name: `Judas`,
		id: `judas`,
		memo: [`Judas: You start off aligned with the TOWN, but when you get lynched for the first time you don't die. Instead, you become aligned with the MAFIA.`],
	},
	king: {
		name: `King`,
		id: `king`,
		memo: [`King (Assassin in the Court): The Assassin wins if you die. The Guards know your identity.`],
	},
	kingmaker: {
		name: `Kingmaker`,
		id: `kingmaker`,
		memo: [`Kingmaker: Each night, you can PM the host the name of a player. The next day this person, if alive, will decide the lynch for that day.`],
	},
	lyncher: {
		name: `Lyncher`,
		id: `lyncher`,
		memo: [`Lyncher: You win when you get a specific player lynched.`],
	},
	millermaker: {
		name: `Millermaker`,
		id: `millermaker`,
		memo: [`Millermaker: Each night, you can PM the host the name of a player. This player will permanently show up as guilty to investigative role.`],
	},
	monarch: {
		name: `Monarch`,
		id: `monarch`,
		memo: [`Monarch: You are Bulletproof, Unlynchable and a Day Vigilante. However, all these abilities go away when any one of them has been activated.`],
	},
	vanilla_cop: `neapolitan`,
	neapolitan: {
		name: `Neapolitan`,
		id: `neapolitan`,
		memo: [`Neapolitan: Each night, you can PM the host the name of a player. You will be told if they are VANILLA or NOT VANILLA, or receive NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	backup_doctor: `nurse`,
	nurse: {
		name: `Nurse`,
		id: `nurse`,
		memo: [`Nurse: When a Doctor dies, you will become a Doctor instead.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-doctor.png"/>`,
	},
	nymphomaniac: {
		name: `Nymphomaniac`,
		id: `nymphomaniac`,
		memo: [`Nymphomaniac: Has to PM the host the name of a player Night 1. You will become Lovers with this player.`],
	},
	one_shot_townie: {
		name: `One Shot Townie`,
		id: `oneshottownie`,
		memo: [`One Shot Townie: Starts out as a Town player. Turns into a Survivor at the start of Day 2.`],
	},
	oracle: {
		name: `Oracle`,
		id: `oracle`,
		memo: [`Oracle: Each night, you can PM the host the name of a player. When you die, you'll publicly reveal this player's role, until you've chosen a different player.`],
	},
	parrot: `parrot_role`,
	wereparrot: `parrot_role`,
	parrot_role: {
		name: `Parrot Role`,
		id: `parrotrole`,
		memo: [`Parrot Role: Each night, you can PM the host the name of a player. If they have an active ability, you use this ability on them.`],
	},
	politician: {
		name: `Politician`,
		id: `politician`,
		memo: [`Politician: Each night, you can PM the host the name of two players. You give the vote of the former player to the latter player for the next day.`],
	},
	hooker: `pretty_lady`,
	pl: `pretty_lady`,
	pretty_lady: {
		name: `Pretty Lady`,
		id: `prettylady`,
		memo: [`Pretty Lady: During the Night, you may PM the host the name of another player. This player won't be able to use an action this Night. If you target a Werewolf performing a kill, you redirect its kill onto you.`],
	},
	pi: `private_investigator`,
	private_investigator: {
		name: `Private Investigator`,
		id: `privateinvestigator`,
		memo: [`Private Investigator: Each night you can PM the host the name of another player. You will be told if they are CULT or NOT CULT, or receive NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	prober: {
		name: `Prober`,
		id: `prober`,
		memo: [`Prober: Each night you can PM the host the name of another player. You will be told if they are WEREWOLF or NOT WEREWOLF, or receive NO RESULT if your investigation failed. Additionally, this player can't perform a night action that night.`],
	},
	pseudojester: {
		name: `Pseudojester`,
		id: `pseudojester`,
		memo: [`Pseudojester: You are only able to win if you get lynched. You will be aligned with the player who placed the last lynch.`],
	},
	pseudolyncher: {
		name: `Pseudolyncher`,
		id: `pseudolyncher`,
		memo: [`Pseudolyncher: You are only able to win if you get your target lynched. You will be aligned with the alignment of this player.`],
	},
	psychiatrist: {
		name: `Psychiatrist`,
		id: `psychiatrist`,
		memo: [`Psychiatrist: During the Night, you may PM the host the name of another player. If this player is a Serial Killer, they will be converted to a Vanilla Townie.`],
	},
	mass_redirector: `psychomagnet`,
	psychomagnet: {
		name: `Psychomagnet`,
		id: `psychomagnet`,
		memo: [`Psychomagnet: During the Night, you may PM the host the name of another player. All other actions used that Night will target this player instead.`],
	},
	reloader: {
		name: `Reloader`,
		id: `reloader`,
		memo: [`Reloader: During the Night, you may PM the host the name of another player. If this player has used an X-Shot action, they regain their shot, allowing them to use the action again.`],
	},
	recruiter: {
		name: `Recruiter`,
		id: `recruiter`,
		memo: [`Recruiter: During the Night, you may PM the host the name of another player. This player will be recruited to your own alignment.`],
	},
	red_goo: {
		name: `Red Goo`,
		id: `redgoo`,
		alignment: `goo`,
		memo: [`Red Goo: Once a game, you may PM the host the name of another player at night. This player will unstoppably die. It is announced that a Red Goo performed this kill.`],
	},
	redirector: {
		name: `Redirector`,
		id: `redirector`,
		memo: [`Redirector: During the Night, you may PM the host the names of two other players. The former player will target the latter player instead.`],
	},
	roleblocker: {
		name: `Roleblocker`,
		id: `roleblocker`,
		memo: [`Roleblocker: During the Night, you may PM the host the name of another player. This player won't be able to use an action this Night.`],
	},
	suppressor: `rolestopper`,
	rolestopper: {
		name: `Rolestopper`,
		id: `rolestopper`,
		memo: [`Rolestopper: Each night you can PM the host the name of another player. All other actions on this player will fail, excluding kills.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-doctor.png"/>`,
	},
	saulus: {
		name: `Saulus`,
		id: `saulus`,
		memo: [`Saulus: You start off aligned with the MAFIA, but when you get lynched for the first time you don't die. Instead, you become aligned with the TOWN.`],
	},
	seer: {
		name: `Seer`,
		id: `seer`,
		memo: [`Seer: During the Night, you may PM the host the name of another player. You will be told if they are WEREWOLF or NOT WEREWOLF, or receive NO RESULT if your investigation failed.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	seraph_knight: {
		name: `Seraph Knight`,
		id: `seraphknight`,
		memo: [`Seraph Knight: Once a game, you may PM the host the name of another player at night. This player will not be able to be killed at night until you die.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-doctor.png"/>`,
	},
	sk: `serial_killer`,
	serial_killer: {
		name: `Serial Killer`,
		id: `serialkiller`,
		memo: [`Serial Killer: You are aligned with yourself and win when you are the last player standing. During the Night, you may PM the host the name of another player. This player will die.`],
	},
	silencer: {
		name: `Silencer`,
		id: `silencer`,
		memo: [`Silencer: During the Night, you may PM the host the name of another player. This player will not be able to talk during the next day. Ask the host whether this player will be able to lynch or not.`],
	},
	kamikaze_pilot: `suicide_bomber`,
	suicide_bomber: {
		name: `Suicide Bomber`,
		id: `suicidebomber`,
		memo: [`Suicide Bomber: During the Night, you may PM the host the name of another player. This player will be killed, but you will die as well.`],
	},
	survivor: {
		name: `Survivor`,
		id: `survivor`,
		memo: [`Survivor: You are aligned with yourself. You win when you are alive when the game ends.`],
	},
	sympathiser: {
		name: `Sympathiser`,
		id: `sympathiser`,
		memo: [`Sympathiser: You are aligned with a specified alignment when there are other players of this alignment in the game. Otherwise, you are TOWN.`],
	},
	tourist: {
		name: `Tourist`,
		id: `tourist`,
		memo: [`Tourist: During the Night, you have to PM the host the name of another player. You'll target this player, without any additional affect.`],
	},
	tracker: {
		name: `Tracker`,
		id: `tracker`,
		memo: [`Tracker: During the Night, you may PM the host the name of another player. You will be told who, if anyone, this player targeted.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
	traitor: {
		name: `Traitor`,
		id: `traitor`,
		memo: [`Traitor: You are aligned with the MAFIA, but are not able to perform the factional kill, and do not know the other members of the Mafia.`],
	},
	unblocker: {
		name: `Unblocker`,
		id: `unblocker`,
		memo: [`Unblocker: During the Night, you may PM the host the name of another player. Their action will not fail.`],
	},
	underdog: {
		name: `Underdog`,
		id: `underdog`,
		memo: [`Underdog: You are aligned with yourself. You start out as a Survivor, but turn into the alignment of the first player to die during a day when they die.`],
	},
	unjester: {
		name: `Unjester`,
		id: `unjester`,
		memo: [`Unjester: You are aligned with yourself. You win when you are killed.`],
	},
	unlyncher: {
		name: `Unlyncher`,
		id: `unlyncher`,
		memo: [`Unlyncher: You are aligned with yourself. To win, you must make sure a specific player is never lynched during the game.`],
	},
	vanillaiser: {
		name: `Vanillaiser`,
		id: `vanillaiser`,
		memo: [`Vanillaiser: During the Night, you may PM the host the name of another player. Starting the next day, this player will lose any role they have, turning into a Vanilla role.`],
	},
	vig: `vigilante`,
	vigilante: {
		name: `Vigilante`,
		id: `vigilante`,
		memo: [`Vigilante: During the Night, you may PM the host the name of another player. This player will be killed.`],
	},
	watcher: {
		name: `Watcher`,
		id: `watcher`,
		memo: [`Watcher: During the Night, you may PM the host the name of another player. You will be told who, if anyone, targeted this player.`],
		image: `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-cop.png"/>`,
	},
};

/** @type {MafiaModifiers} */
const modifiers = {
	// passive abilities
	active: {
		name: `Active`,
		id: `active`,
		memo: [`Active: You can choose when to activate your role.`],
	},
	alpha: {
		name: `Alpha`,
		id: `alpha`,
		memo: [`Alpha: You will be inspected as NOT WEREWOLF.`],
	},
	ascetic: {
		name: `Ascetic`,
		id: `ascetic`,
		memo: [`Ascetic: Actions on you will fail, excluding kills.`],
	},
	bp: `bulletproof`,
	bulletproof: {
		name: `Bulletproof`,
		id: `bulletproof`,
		memo: [`Bulletproof: You cannot be nightkilled.`],
	},
	clairvoyant: {
		name: `Clairvoyant`,
		id: `clairvoyant`,
		memo: [`Clairvoyant: You get to know how many different alignments are in the game.`],
	},
	compulsive: {
		name: `Compulsive`,
		id: `compulsive`,
		memo: [`Compulsive: You must your use action each night.`],
	},
	cck: `compulsive_child_killer`,
	compulsive_child_killer: {
		name: `Compulsive Child Killer`,
		id: `compulsivechildkiller`,
		memo: [`Compulsive Child Killer: Whenever an Innocent Child (or a variation of one) reveals itself, you will immediately kill them.`],
	},
	contrary: {
		name: `Contrary`,
		id: `contrary`,
		memo: [`Contrary: Your action only succeeds when it'd fail without this modifier.`],
	},
	day: {
		name: `Day`,
		id: `day`,
		memo: [`Day: You have to use your action during the Day.`],
	},
	death: {
		name: `Death`,
		id: `death`,
		memo: [`Death: You can use your action upon dying.`],
	},
	deathproof: {
		name: `Deathproof`,
		id: `deathproof`,
		memo: [`Deathproof: You can't die.`],
	},
	doppelganger: {
		name: `Doppelganger`,
		id: `doppelganger`,
		memo: [`Doppelganger: All investigative actions on you return results for the target on the left of you on the userlist.`],
	},
	enabler: {
		name: `Enabler`,
		id: `enabler`,
		memo: [`Enabler: When you die, a certain role can't be used anymore.`],
	},
	evangelistic: {
		name: `Evangelistic`,
		id: `evangelistic`,
		memo: [`Evangelistic: You will be inspected as CULT.`],
	},
	friend: {
		name: `Friend`,
		id: `friend`,
		memo: [`Friend: Besides your normal win-condition, you can win when only Friends are left alive. You can talk to other Friends.`],
	},
	godfather: {
		name: `Godfather`,
		id: `godfather`,
		memo: [`Godfather: You will be inspected as NOT MAFIA.`],
	},
	gravedigger: {
		name: `Gravedigger`,
		id: `gravedigger`,
		memo: [`Gravedigger: You will return as if you targeted the player who died to Watchers and Trackers.`],
	},
	haunting: {
		name: `Haunting`,
		id: `haunting`,
		memo: [`Haunting: You can only use your actions after you've died.`],
	},
	hero: {
		name: `Hero`,
		id: `hero`,
		memo: [`Hero: When a King (from Kingmaker) tries to execute you, they die instead.`],
	},
	hirsute: {
		name: `Hirsute`,
		id: `hirsute`,
		memo: [`Hirsute: You will be inspected as WEREWOLF.`],
	},
	lightning_rod: {
		name: `Lightning Rod`,
		id: `lightningrod`,
		memo: [`Lightning Rod: All actions target you.`],
	},
	lover: {
		name: `Lover`,
		id: `lover`,
		memo: [`Lover: You get a Lover partner, who you can talk with. If either of you dies, the other dies as well.`],
	},
	lynchbait: {
		name: `Lynchbait`,
		id: `lynchbait`,
		memo: [`Lynchbait: All Lynchers win when you get lynched.`],
	},
	macho: {
		name: `Macho`,
		id: `macho`,
		memo: [`Macho: You cannot be protected from being killed.`],
	},
	mason: {
		name: `Mason`,
		id: `mason`,
		memo: [`Mason: You can speak to other Masons, who are confirmed to not be members of the MAFIA.`],
	},
	doublevoter: `mayor`,
	mayor: {
		name: `Mayor`,
		id: `mayor`,
		memo: [`Mayor: Your lynch counts as two.`],
	},
	miller: {
		name: `Miller`,
		id: `miller`,
		memo: [`Miller: You will always be inspected as MAFIA.`],
	},
	monk: {
		name: `Monk`,
		id: `monk`,
		memo: [`Monk: You can speak to other Monks, who are confirmed to not be WEREWOLVES.`],
	},
	named: {
		name: `Named`,
		id: `named`,
		memo: [`Named: You got a different role name than usual.`],
	},
	neighbor: {
		name: `Neighbor`,
		id: `neighbor`,
		memo: [`Neighbor: You can talk to other Neighbors.`],
	},
	midnight: `night`,
	night: {
		name: `Night`,
		id: `night`,
		memo: [`Night: You have to use your action during the Night.`],
	},
	ninja: {
		name: `Ninja`,
		id: `ninja`,
		memo: [`Ninja: Trackers, Watchers and similar roles will always get it as if you targeted nobody, or nobody targeted you.`],
	},
	omniscient: {
		name: `Omniscient`,
		id: `omniscient`,
		memo: [`Omniscient: You know all roles that are present in the setup.`],
	},
	pacifist: {
		name: `Pacifist`,
		id: `pacifist`,
		memo: [`Pacifist: You are unable to kill.`],
	},
	pgo: `paranoid_gun_owner`,
	paranoid_gun_owner: {
		name: `Paranoid Gun Owner`,
		id: `paranoidgunowner`,
		memo: [`Paranoid Gun Owner: You kill anyone who targets you.`],
	},
	passive: {
		name: `Passive`,
		id: `passive`,
		memo: [`Passive: You cannot choose when to activate your role.`],
	},
	psychotrooper: {
		name: `Psychotrooper`,
		id: `psychotrooper`,
		memo: [`Psychotrooper: All investigative results are reversed while you are alive.`],
	},
	random: {
		name: `Random`,
		id: `random`,
		memo: [`Random: Your role is used randomly.`],
	},
	reflexive: {
		name: `Reflexive`,
		id: `reflexive`,
		memo: [`Reflexive: You use your action on people who target you.`],
	},
	restless_spirit: {
		name: `Restless Spirit`,
		id: `restlessspirit`,
		memo: [`Restless Spirit: You can lynch after your death.`],
	},
	retired_marine: {
		name: `Retired Marine`,
		id: `retiredmarine`,
		memo: [`Retired Marine: You cannot be killed by Serial Killers.`],
	},
	retired_werewolf_hunter: {
		name: `Retired Werewolf Hunter`,
		id: `retiredwerewolfhunter`,
		memo: [`Retired Werewolf Hunter: You cannot be killed by Werewolves.`],
	},
	sacrifice: {
		name: `Sacrifice`,
		id: `sacrifice`,
		memo: [`Sacrifice: No one else can die, besides other Sacrifices, until you die.`],
	},
	self: {
		name: `Self`,
		id: `self`,
		memo: [`Self: You must target yourself.`],
	},
	senpai: {
		name: `Senpai`,
		id: `senpai`,
		memo: [`Senpai: When you get lynched, everyone who lynched you dies as well.`],
	},
	strongman: {
		name: `Strongman`,
		id: `strongman`,
		memo: [`Strongman: Your kill can not fail.`],
	},
	strong_willed: `strong-willed`,
	strongwilled: `strong-willed`,
	'strong-willed': {
		name: `Strong-Willed`,
		id: `strongwilled`,
		memo: [`Strong-Willed: Your actions can not fail, excluding kills.`],
	},
	suicidal: {
		name: `Suicidal`,
		id: `suicidal`,
		memo: [`Suicidal: You will passively die.`],
	},
	avenger: `supersaint`,
	ss: `supersaint`,
	supersaint: {
		name: `Supersaint`,
		id: `supersaint`,
		memo: [`Supersaint: When this player is lynched, the player who placed the hammering vote dies as well..`],
	},
	temporary: {
		name: `Temporary`,
		id: `temporary`,
		memo: [`Temporary: Only affects the target for one night.`],
	},
	tentacled: {
		name: `Tentacled`,
		id: `tentacled`,
		memo: [`Tentacled: You will always be inspected as ALIEN.`],
	},
	tree: {
		name: `Tree`,
		id: `tree`,
		memo: [`Tree: You can talk after your death, provided you died due to a lynch. You can still be primed and ignited by Arsonists afterwards.`],
	},
	treestump: {
		name: `Treestump`,
		id: `treestump`,
		memo: [`Treestump: You can talk after your death.`],
	},
	lynchproof: `unlynchable`,
	unlynchable: {
		name: `Unlynchable`,
		id: `unlynchable`,
		memo: [`Unlynchable: You cannot be lynched. If you're lynched, you will survive and the game will turn to Night.`],
	},
	vengeful: {
		name: `Vengeful`,
		id: `vengeful`,
		memo: [`Vengeful: When this player is lynched, they can kill another player.`],
	},
	watchlisted: {
		name: `Watchlisted`,
		id: `watchlisted`,
		memo: [`Watchlisted: You will always be inspected as SERIAL KILLER.`],
	},
	weak: {
		name: `Weak`,
		id: `weak`,
		memo: [`Weak: You will die if you target a player who is not aligned with the TOWN.`],
	},
	wrong_place_at_the_wrong_time: {
		name: `Wrong Place at the Wrong Time`,
		id: `wrongplaceatthewrongtime`,
		memo: [`Wrong Place at the Wrong Time: You will always be inspected as the result that implies NOT TOWN.`],
	},
	xshot: {
		// Role generator will change X to the number of shots the player gets
		name: `X-Shot`,
		id: `xshot`,
		memo: [`X-Shot: You may only use this ability X times during the game.`],
	},
};

/** @type {MafiaThemes} */
const themes = {
	aitc: `assassin_in_the_court`,
	aitp: `assassin_in_the_court`,
	assassin_in_the_castle: `assassin_in_the_court`,
	assassin_in_the_palace: `assassin_in_the_court`,
	assassin_in_the_court: {
		name: `Assassin in the Court`,
		desc: `The Assassin tries to shoot the King to win! The Guards try to protect the King.`,
		4: `Solo Assassin, Guard, Guard, King`,
		5: `Solo Assassin, Guard, Guard, Guard, King`,
		6: `Solo Assassin, Guard, Guard, Guard, Guard, King`,
		7: `Solo Assassin, Guard, Guard, Guard, Guard, Guard, King`,
	},
	classic: {
		name: `Classic`,
		desc: `Classic: A PS! Mafia Classic. It's common, strategic, and fun!`,
		6: `Mafia Goon, Mafia Goon, Role Cop, Jailkeeper, Vanilla Townie, Vanilla Townie`,
		7: `Mafia Goon, Mafia Goon, Macho Role Cop, Doctor, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		8: `Mafia Pretty Lady, Mafia Goon, Role Cop, Doctor, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		9: `Mafia Goon, Mafia Pretty Lady, Role Cop, Doctor, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		10: `Mafia Goon, Mafia Pretty Lady, Bulletproof Werewolf, Role Cop, Doctor, Pretty Lady, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		11: `Mafia Goon, Mafia Pretty Lady, Bulletproof Werewolf, Role Cop, Doctor, Pretty Lady, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		12: `Mafia Goon, Mafia Pretty Lady, Bulletproof Werewolf, Role Cop, Doctor, Pretty Lady, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		13: `Mafia Goon, Mafia Pretty Lady, Bulletproof Werewolf, Role Cop, Doctor, Pretty Lady, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		14: `Mafia Goon, Mafia Goon, Mafia Pretty Lady, Bulletproof Werewolf, Role Cop, Doctor, Pretty Lady, Jailkeeper, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		15: `Mafia Goon, Mafia Role Cop, Mafia Pretty Lady, Bulletproof Werewolf One-Shot Strongman, Role Cop, Doctor, Doctor, Pretty Lady, Jailkeeper, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		16: `Mafia Goon, Mafia Role Cop, Mafia Pretty Lady, Bulletproof Werewolf One-Shot Strongman, Role Cop, Doctor, Doctor, Pretty Lady, Jailkeeper, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		17: `Mafia Goon, Mafia Role Cop, Mafia Pretty Lady, Bulletproof Werewolf One-Shot Strongman, Role Cop, Doctor, Doctor, Pretty Lady, Jailkeeper, One-Shot Vigilante, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		18: `Mafia Goon, Mafia Role Cop, Mafia Pretty Lady, Bulletproof Werewolf One-Shot Strongman, Role Cop, Doctor, Doctor, Pretty Lady, Jailkeeper, One-Shot Vigilante, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		19: `Mafia Goon, Mafia Goon, Mafia Role Cop, Mafia Pretty Lady, Bulletproof Werewolf One-Shot Strongman, Role Cop, Doctor, Doctor, Pretty Lady, Jailkeeper, One-Shot Vigilante, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		20: `Mafia Goon, Mafia Goon, Mafia Role Cop, Mafia Pretty Lady, Bulletproof Werewolf One-Shot Strongman, Role Cop, Doctor, Doctor, Pretty Lady, Jailkeeper, One-Shot Vigilante, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
	},
	dethy: {
		name: `Dethy`,
		desc: `Dethy: Four Cops against one Mafia Goon. They just won't always get the correct results...`,
		5: `Mafia Goon, Cop, Cop, Cop, Cop`,
	},
	esun: 'eternal_sun',
	eternal_sun: {
		name: `Eternal Sun`,
		desc: `Eternal Sun: A theme without nights! Everyone can use their action once a day.`,
		7: `Mafia Compulsive Janitor, Mafia Coroner, Coroner, Gunsmith, Blacksmith, Vanilla Townie, Vanilla Townie`,
		8: `Mafia Compulsive Janitor, Mafia Coroner, Coroner, Gunsmith, Blacksmith, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		9: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Goon, Coroner, Gunsmith, Blacksmith, Innocent Child, Vanilla Townie, Vanilla Townie`,
		10: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Goon, Coroner, Coroner, Gunsmith, Blacksmith, Innocent Child, Vanilla Townie, Vanilla Townie`,
		11: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Goon, Coroner, Coroner, Gunsmith, Blacksmith, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		12: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Suicide Bomber, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		13: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Suicide Bomber, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		14: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Suicide Bomber, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		15: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Suicide Bomber, Mafia Goon, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		16: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Suicide Bomber, Mafia Goon, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		17: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Suicide Bomber, Mafia Goon, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		18: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Coroner, Mafia Suicide Bomber, Coroner, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		19: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Coroner, Mafia Suicide Bomber, Coroner, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		20: `Mafia Compulsive Janitor, Mafia Coroner, Mafia Coroner, Mafia Suicide Bomber, Mafia Goon, Coroner, Coroner, Coroner, Gunsmith, Blacksmith, Organ Donor, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
	},
	ff: `forest_fire`,
	forest_fire: {
		name: `Forest Fire`,
		desc: `Forest Fire: The forest risks being burned down! Stop the Arsonists before it's too late.`,
		9: `Arsonist, Arsonist, Tree, Tree, Tree, Tree, Tree, Tree, Firefighter`,
	},
	job: `jungle_of_bullshit`,
	jungle_of_bullshit: {
		name: `Jungle of Bullshit`,
		desc: `Jungle of Bullshit: When a Vanilla Townie is lynched Day 1, they shoot two players instead. When a Mafia Goon is lynched, they kill one of their partners and clear a Vanilla Townie.`,
		5: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie`,
	},
	kwg: `kids_with_guns`,
	kids_with_guns: {
		name: `Kids With Guns`,
		desc: `Kids With Guns: A theme based around roles that can kill people!`,
		8: `Mafia Suicide Bomber, Mafia Goon, One-Shot Vigilante, Innocent Child, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
	},
	lh: `lighthouse`,
	lighthouse: {
		name: `Lighthouse`,
		desc: `Lighthouse: A theme where the town has a Lightkeeper. When this role dies, the next day is anonymous!`,
		5: `Mafia Goon, Lightkeeper, Oracle, Oracle, Oracle`,
		6: `Mafia Goon, Mafia Goon, Lightkeeper, Gunsmith, Oracle, Oracle`,
		7: `Mafia Goon, Mafia Goon, Lightkeeper, Gunsmith, Oracle, Oracle, Oracle`,
		8: `Mafia Goon, Mafia Goon, Lightkeeper, Gunsmith, Gunsmith, Oracle, Oracle, Oracle`,
		9: `Mafia Goon, Mafia Gunsmith, Lightkeeper, Gunsmith, Gunsmith, Oracle, Oracle, Oracle, Oracle`,
		10: `Mafia Goon, Mafia Gunsmith, Lightkeeper, Gunsmith, Gunsmith, Oracle, Oracle, Oracle, Oracle, Oracle`,
		11: `Mafia Goon, Mafia Goon, Mafia Goon, Lightkeeper, Gunsmith, Gunsmith, Oracle, Oracle, Oracle, Oracle, Oracle`,
		12: `Mafia Goon, Mafia Goon, Mafia Goon, Lightkeeper, Gunsmith, Gunsmith, Oracle, Oracle, Oracle, Oracle, Oracle, Oracle`,
		13: `Mafia Goon, Mafia Goon, Mafia Gunsmith, Lightkeeper, Gunsmith, Gunsmith, Gunsmith, Oracle, Oracle, Oracle, Oracle, Oracle, Oracle`,
	},
	medmaf: `medical_mafia`,
	medical_mafia: {
		name: `Medical Mafia`,
		desc: `Medical Mafia: A theme where the Mafia invade a hospital. The Mafia has to beat a group of Doctors... who may not all heal their patients.`,
		9: `Mafia Goon, Mafia Goon, Doctor, Doctor, Doctor, Doctor, Doctor, Doctor, Nurse`,
	},
	nd: `neighbors_dilemma`,
	neighbors_dilemma: {
		name: `Neighbors Dilemma`,
		desc: `Neighbors Dilemma: A theme where you get a Neighbor, who you can privately talk to. However, they may be scum...`,
		6: `Solo Odd-Night Serial Killer Neighbor, Solo Even-Night Serial Killer Neighbor, Town Neighbor, Town Neighbor, Town Neighbor, Town Neighbor`,
	},
	sacrifice: {
		name: `Sacrifice`,
		desc: `Sacrifice: The Vanilla Townies can't die until a Mafia Sacrifice has died. Use this to clear them!`,
		4: `Mafia Sacrifice, Mafia Sacrifice, Vanilla Townie, Vanilla Townie`,
	},
	senpai: {
		name: `Senpai`,
		desc: `Senpai: When a Senpai dies, everyone who lynched them dies as well!`,
		7: `Mafia Goon, Mafia Goon, Senpai, Senpai, Senpai, Senpai, Senpai`,
	},
	ss3: `supersaint3`,
	supersaint3: {
		name: `SS3`,
		desc: `SS3: A three-player theme where even the Mafia has to be careful of whom they hammer!`,
		3: `Mafia Goon, Supersaint, Vanilla Townie`,
	},
	nilla: `vanilla`,
	vanilla: {
		name: `Vanilla`,
		desc: `A simple theme with only Mafia Goons and Vanilla Townies.`,
		4: `Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		5: `Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		6: `Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		7: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		8: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		9: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		10: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		11: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		12: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		13: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		14: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		15: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		16: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		17: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		18: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		19: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
		20: `Mafia Goon, Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
	},
	wnac: `we_need_a_clear`,
	we_need_a_clear: {
		name: `We Need a Clear`,
		desc: `We Need a Clear: When a Vanilla Townie is lynched Day 1, they get cleared instead.`,
		5: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie, Vanilla Townie`,
	},
	wnaf: `we_need_a_fifth`,
	we_need_a_fifth: {
		name: `We Need a Fifth`,
		desc: `We Need a Fifth: When a Vanilla Townie is lynched Day 1, they shoot another player instead. When a Mafia Goon is lynched, they have to clear a Vanilla Townie.`,
		4: `Mafia Goon, Mafia Goon, Vanilla Townie, Vanilla Townie`,
	},
};

/** @type {MafiaIDEAs} */
const IDEAs = {
	gi: `greater_idea`,
	greater_idea: {
		name: `Greater Idea`,
		roles: [
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Watcher`,
			`Tracker`,
			`Tracker`,
			`Cop`,
			`Cop`,
			`Cop Lover`,
			`Seer`,
			`Seer`,
			`FBI Agent`,
			`Doctor`,
			`Doctor`,
			`Roleblocker`,
			`Jailkeeper`,
			`Bodyguard`,
			`Vigilante`,
			`One-Shot Vigilante`,
			`One-Shot Day Vigilante`,
			`One-Shot Day Vigilante`,
			`Compulsive Childkiller`,
			`Bulletproof Townie`,
			`Supersaint`,
			`One-Shot Paranoid Gun Owner`,
			`Mason`,
			`Mason`,
			`Mason`,
			`Mason`,
			`Mason Doctor`,
			`Mason Lover`,
			`Lover`,
			`Lover`,
			`Lover`,
			`Jack-of-all-Trades`,
			`Vengeful Townie`,
			`Retired Werewolf Hunter`,
			`Retired Marine`,
			`Miller`,
			`Hirsute Townie`,
			`Evangelistic Townie`,
			`Tentacled Townie`,
			`Watchlisted Townie`,
			`Wrong Place at the Wrong Time Townie`,
			`Town Black Goo`,
			`Ascetic Townie`,
			`Private Investigator`,
			`Gravedigger`,
			`Nymphomaniac`,
			`One-Shot Governor`,
			`One-Shot Unlynchable Townie`,
			`Town Godfather`,
			`Innocent Child`,
			`Hider`,
			`Enabler`,
			`Treestump`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`One-Shot Kingmaker`,
			`Weak Jailkeeper`,
			`Bloodhound`,
			`Vanilla Cop`,
			`Hero`,
			`Tourist`,
			`Nurse`,
			`One-Shot Commuter`,
			`Cop-of-all-Trades`,
			`One-Shot Gladiator`,
			`Lynchbait`,
			`Psychiatrist`,
			`Reloader`,
			`Fruit Vendor`,
			`Parrot Role`,
			`Solo Judas`,
			`Solo Saulus`,
			`Solo One-Shot Townie`,
			`Solo Underdog`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Godfather`,
			`Mafia Tracker`,
			`Mafia Doctor`,
			`Mafia Roleblocker`,
			`Mafia Lover`,
			`Mafia Seer`,
			`Mafia One-Shot Day Vigilante`,
			`Mafia One-Shot Governor`,
			`Mafia Reflexive Doctor`,
			`Hirsute Mafia Goon`,
			`Mafia Cupid`,
			`Alpha Goon`,
			`Mafia Compulsive Hider`,
			`Mafia Fruit Vendor`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Alpha Werewolf`,
			`Werewolf Roleblocker`,
			`One-Shot Bulletproof Werewolf`,
			`Werewolf Cop`,
			`Werewolf Mason`,
			`Werewolf Watcher`,
			`Werewolf FBI Agent`,
			`Ninja Werewolf`,
			`Werewolf One-Shot Paranoid Gun Owner`,
			`Werewolf Miller`,
			`Werewolf Supersaint`,
			`Werewolf Godfather`,
			`Werewolf Gravedigger`,
			`Werewolf Wereparrot`,
			`One-Shot Unlynchable Alien`,
			`Alien Prober`,
			`Alien Vanillaiser`,
			`Alien Silencer`,
			`Bulletproof Alien Lover`,
			`Alien Psychotrooper`,
			`Alien One-Shot Mass Redirector`,
			`Alien Bloodsucker`,
			`Alien Sympathiser`,
			`Solo Survivor`,
			`Solo Compulsive Bodyguard Survivor`,
			`Solo Survivor Mason`,
			`Solo Lyncher`,
			`Solo Lyncher`,
			`Solo Two-Shot Bulletproof Serial Killer`,
			`Solo Serial Killer (Immune to Mafia Kills)`,
			`Solo Serial Killer (Immune to Werewolf Kills)`,
			`Solo Serial Killer (Immune to Alien Kills)`,
			`One-Shot Cult Recruiter`,
			`One-Shot Cult Goomaker`,
			`Solo Wild Card`,
		],
		picks: [`role`],
		choices: 2,
	},
	gesti: `greatest_idea`,
	greatest_idea: {
		name: `Greatest Idea`,
		roles: [
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Watcher`,
			`Tracker`,
			`Tracker`,
			`Cop`,
			`Cop`,
			`Cop Lover`,
			`Seer`,
			`Seer`,
			`FBI Agent`,
			`Doctor`,
			`Doctor`,
			`Roleblocker`,
			`Jailkeeper`,
			`Bodyguard`,
			`Vigilante`,
			`One-Shot Vigilante`,
			`One-Shot Day Vigilante`,
			`One-Shot Day Vigilante`,
			`Compulsive Childkiller`,
			`Bulletproof Townie`,
			`Supersaint`,
			`One-Shot Paranoid Gun Owner`,
			`Mason`,
			`Mason`,
			`Mason`,
			`Mason`,
			`Mason Doctor`,
			`Mason Lover`,
			`Lover`,
			`Lover`,
			`Lover`,
			`Jack-of-all-Trades`,
			`Vengeful Townie`,
			`Retired Werewolf Hunter`,
			`Retired Marine`,
			`Miller`,
			`Hirsute Townie`,
			`Evangelistic Townie`,
			`Tentacled Townie`,
			`Watchlisted Townie`,
			`Wrong Place at the Wrong Time Townie`,
			`Town Black Goo`,
			`Ascetic Townie`,
			`Private Investigator`,
			`Gravedigger`,
			`Nymphomaniac`,
			`One-Shot Governor`,
			`One-Shot Unlynchable Townie`,
			`Town Godfather`,
			`Innocent Child`,
			`Hider`,
			`Enabler`,
			`Treestump`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`One-Shot Kingmaker`,
			`Weak Jailkeeper`,
			`Bloodhound`,
			`Vanilla Cop`,
			`Hero`,
			`Tourist`,
			`Nurse`,
			`One-Shot Commuter`,
			`Cop-of-all-Trades`,
			`One-Shot Gladiator`,
			`Lynchbait`,
			`Psychiatrist`,
			`Reloader`,
			`Fruit Vendor`,
			`Parrot Role`,
			`Solo Judas`,
			`Solo Saulus`,
			`Solo One-Shot Townie`,
			`Solo Underdog`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Godfather`,
			`Mafia Tracker`,
			`Mafia Doctor`,
			`Mafia Roleblocker`,
			`Mafia Lover`,
			`Mafia Seer`,
			`Mafia One-Shot Day Vigilante`,
			`Mafia One-Shot Governor`,
			`Mafia Reflexive Doctor`,
			`Hirsute Mafia Goon`,
			`Mafia Cupid`,
			`Alpha Mafia Goon`,
			`Mafia Compulsive Hider`,
			`Mafia Fruit Vendor`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Alpha Werewolf`,
			`Werewolf Roleblocker`,
			`One-Shot Bulletproof Werewolf`,
			`Werewolf Cop`,
			`Werewolf Mason`,
			`Werewolf Watcher`,
			`Werewolf FBI Agent`,
			`Ninja Werewolf`,
			`Werewolf One-Shot Paranoid Gun Owner`,
			`Werewolf Miller`,
			`Werewolf Supersaint`,
			`Werewolf Godfather`,
			`Werewolf Gravedigger`,
			`Werewolf Wereparrot`,
			`One-Shot Unlynchable Alien`,
			`Alien Prober`,
			`Alien Vanillaiser`,
			`Alien Silencer`,
			`Bulletproof Alien Lover`,
			`Alien Psychotrooper`,
			`Alien One-Shot Mass Redirector`,
			`Alien Bloodsucker`,
			`Alien Sympathiser`,
			`Solo Survivor`,
			`Solo Compulsive Bodyguard Survivor`,
			`Solo Survivor Mason`,
			`Solo Lyncher`,
			`Solo Lyncher`,
			`Solo Two-Shot Bulletproof Serial Killer`,
			`Solo Serial Killer (Immune to Mafia Kills)`,
			`Solo Serial Killer (Immune to Werewolf Kills)`,
			`Solo Serial Killer (Immune to Alien Kills)`,
			`One-Shot Cult Recruiter`,
			`One-Shot Cult Goomaker`,
			`Solo Wild Card`,
		],
		picks: [`role`, `alignment`],
		choices: 3,
	},
	rgi: `replicant_greater_idea`,
	replicant_greater_idea: {
		name: `Replicant Greater Idea`,
		roles: [
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Watcher`,
			`Tracker`,
			`Tracker`,
			`Cop`,
			`Cop`,
			`Cop Lover`,
			`Seer`,
			`Seer`,
			`FBI Agent`,
			`Doctor`,
			`Doctor`,
			`Roleblocker`,
			`Jailkeeper`,
			`Bodyguard`,
			`Vigilante`,
			`One-Shot Vigilante`,
			`One-Shot Day Vigilante`,
			`One-Shot Day Vigilante`,
			`Compulsive Childkiller`,
			`Bulletproof Townie`,
			`Supersaint`,
			`One-Shot Paranoid Gun Owner`,
			`Mason`,
			`Mason`,
			`Mason`,
			`Mason`,
			`Mason Doctor`,
			`Mason Lover`,
			`Lover`,
			`Lover`,
			`Lover`,
			`Jack-of-all-Trades`,
			`Vengeful Townie`,
			`Retired Werewolf Hunter`,
			`Retired Marine`,
			`Miller`,
			`Hirsute Townie`,
			`Evangelistic Townie`,
			`Tentacled Townie`,
			`Watchlisted Townie`,
			`Wrong Place at the Wrong Time Townie`,
			`Town Black Goo`,
			`Ascetic Townie`,
			`Private Investigator`,
			`Gravedigger`,
			`Nymphomaniac`,
			`One-Shot Governor`,
			`One-Shot Unlynchable Townie`,
			`Town Godfather`,
			`Innocent Child`,
			`Hider`,
			`Enabler`,
			`Treestump`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`One-Shot Kingmaker`,
			`Weak Jailkeeper`,
			`Bloodhound`,
			`Vanilla Cop`,
			`Hero`,
			`Tourist`,
			`Nurse`,
			`One-Shot Commuter`,
			`Cop-of-all-Trades`,
			`One-Shot Gladiator`,
			`Lynchbait`,
			`Psychiatrist`,
			`Reloader`,
			`Fruit Vendor`,
			`Parrot Role`,
			`Solo Judas`,
			`Solo Saulus`,
			`Solo One-Shot Townie`,
			`Solo Underdog`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Godfather`,
			`Mafia Tracker`,
			`Mafia Doctor`,
			`Mafia Roleblocker`,
			`Mafia Lover`,
			`Mafia Seer`,
			`Mafia One-Shot Day Vigilante`,
			`Mafia One-Shot Governor`,
			`Mafia Reflexive Doctor`,
			`Hirsute Mafia Goon`,
			`Mafia Cupid`,
			`Alpha Mafia Goon`,
			`Mafia Compulsive Hider`,
			`Mafia Fruit Vendor`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Alpha Werewolf`,
			`Werewolf Roleblocker`,
			`One-Shot Bulletproof Werewolf`,
			`Werewolf Cop`,
			`Werewolf Mason`,
			`Werewolf Watcher`,
			`Werewolf FBI Agent`,
			`Ninja Werewolf`,
			`Werewolf One-Shot Paranoid Gun Owner`,
			`Werewolf Miller`,
			`Werewolf Supersaint`,
			`Werewolf Godfather`,
			`Werewolf Gravedigger`,
			`Werewolf Wereparrot`,
			`Replicant One-Shot Lightning Rod`,
			`Replicant Odd-Night Cop Even-Night Seer`,
			`Replicant Doppelganger`,
			`Replicant Suppressor`,
			`Replicant Millermaker`,
			`Replicant One-Shot Politician`,
			`Replicant Day Suicide Bomber`,
			`Bulletproof Replicant`,
			`Replicant Sympathiser`,
			`Solo Survivor`,
			`Solo Compulsive Bodyguard Survivor`,
			`Solo Survivor Mason`,
			`Solo Lyncher`,
			`Solo Lyncher`,
			`Solo Two-Shot Bulletproof Serial Killer`,
			`Solo Serial Killer (Immune to Mafia Kills)`,
			`Solo Serial Killer (Immune to Werewolf Kills)`,
			`Solo Serial Killer (Immune to Alien Kills)`,
			`One-Shot Cult Recruiter`,
			`One-Shot Cult Goomaker`,
			`Solo Wild Card`,
		],
		picks: [`role`],
		choices: 2,
	},
	vi: `vanilla_idea`,
	vanilla_idea: {
		name: `Vanilla Idea`,
		roles: [
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Town`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Mafia`,
			`Traitor`,
			`Traitor`,
			`Traitor`,
			`Traitor`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Werewolf`,
			`Cult`,
			`Cult`,
			`Cult`,
			`Cult`,
			`Cult`,
			`Solo Serial Killer`,
			`Solo Serial Killer`,
			`Solo Serial Killer`,
			`Solo Serial Killer`,
			`Solo Serial Killer`,
			`Solo Survivor`,
			`Solo Survivor`,
			`Solo Jester`,
			`Solo Unjester`,
			`Solo Lyncher`,
			`Solo Unlyncher`,
			`Solo Underdog`,
			`Solo Aligner`,
			`Solo Universal Usurper`,
			`Solo Universal Sympathiser`,
			`Solo Wild Card`,
		],
		picks: [`role`],
		choices: 2,
	},
	ci: `cracking_idea`,
	cracking_idea: {
		name: `Cracking Idea`,
		roles: [
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Vanilla Townie`,
			`Doctor`,
			`Doctor`,
			`Coroner Cracking Idea`,
			`Coroner Cracking Idea`,
			`Coroner Cracking Idea`,
			`Coroner Cracking Idea`,
			`Bodyguard`,
			`Bodyguard`,
			`One-Shot Commuter`,
			`Cop`,
			`Cop`,
			`Ascetic Cop`,
			`Backup Cop `,
			`Watcher`,
			`Tracker`,
			`Hider`,
			`Ascetic Hider`,
			`Area 51 Detective`,
			`Area 51 Immunologist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Conspiracy Theorist`,
			`Compulsive Roleblocker`,
			`Jailkeeper`,
			`Jailkeeper`,
			`Jack Of All Trades `,
			`Mason`,
			`Mason`,
			`Mason`,
			`Ascetic Mason`,
			`Mason Compulsive Bodyguard`,
			`Mason Reflexive Doctor`,
			`One-Shot Vigilante`,
			`Miller Vigilante`,
			`One-Shot Day Vigilante`,
			`Nymphomaniac `,
			`Excellent Sense of Smell Townie`,
			`Excellent Sense of Smell Townie`,
			`Ugly Townie`,
			`Ugly Townie`,
			`Clairvoyant`,
			`Clairvoyant`,
			`Clairvoyant`,
			`Clairvoyant`,
			`Treestump`,
			`Lynchbait`,
			`Macho One-Shot Kingmaker`,
			`Macho Death Kingmaker`,
			`Supersaint`,
			`Vengeful Townie`,
			`One-Shot Unlynchable Townie`,
			`Universal Backup`,
			`Universal Backup`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Mafia Goon`,
			`Ascetic Mafia Goon`,
			`Ascetic Mafia Goon`,
			`Bulletproof Mafia Goon`,
			`Bulletproof Mafia Goon`,
			`Mafia Tracker`,
			`Mafia One-Shot Role Cop`,
			`Mafia One-Shot Role Cop`,
			`Mafia Traitor Cop`,
			`Mafia Conspiracy Theorist`,
			`Mafia Conspiracy Theorist`,
			`Mafia Clairvoyant`,
			`Mafia Clairvoyant`,
			`Mafia One-Shot Day Vigilante`,
			`Mafia Godfather`,
			`Alien Avenger`,
			`Alien Avenger`,
			`Alien Vanillerizer`,
			`Alien Vanillerizer`,
			`Alien Psychotrooper`,
			`Alien One-Shot Psychomagnet`,
			`Alien Monarch`,
			`Baby Alien Monarch`,
			`Baby Alien Monarch`,
			`Solo Lyncher`,
			`Solo Pseudojester`,
			`Red Goo `,
			`Red Goo`,
			`Grey Goo`,
			`Chameleon Goo`,
		],
		picks: [`role`],
		choices: 2,
	},
	si: `snaqs_idea`,
	snaqs_idea: {
		name: `Snaq's Idea`,
		roles: [
			`Vanilla Townie`,
			`Discard`,
			`Hater`,
			`Hater`,
			`Praiser`,
			`Praiser`,
			`Hasty Lover`,
			`Hasty Lover`,
			`Loverboy`,
			`Compulsive Screamer`,
			`Secret Agent`,
			`Secret Agent`,
			`Oracle`,
			`Oracle`,
			`Oracle`,
			`Deactivator`,
			`Deactivator`,
			`Mayor`,
			`Mayor`,
			`Enabler`,
			`Enabler`,
			`Pariah`,
			`Pariah`,
			`Missionary`,
			`Missionary`,
			`Missionary`,
			`OS Curfew Agent`,
			`OS Curfew Agent`,
			`Homekeeper`,
			`Homekeeper`,
			`Homekeeper`,
			`Vanguard`,
			`Vanguard`,
			`Vanguard`,
			`Cowardly Hero`,
			`Cowardly Hero`,
			`Cop-Of-All-Trades`,
			`Cop-Of-All-Trades`,
			`Cop-Of-All-Trades`,
			`Journalist`,
			`Journalist`,
			`Journalist`,
			`Compatibility Checker`,
			`Compatibility Checker`,
			`Compatibility Checker`,
			`Teacher`,
			`Teacher`,
			`Teacher`,
			`Power Cop`,
			`Power Cop`,
			`Tallier`,
			`Yogi Bear`,
			`Innocent Child`,
			`Innocent Child`,
			`Innocent Child`,
			`Day 4 Suicidal Deathproof Townie`,
			`Treestump`,
			`Treestump`,
			`Illusionist`,
			`Illusionist`,
			`OS Subway Recruiter`,
			`OS Subway Recruiter`,
			`Detector`,
			`Detector`,
			`Detector`,
			`Blockade`,
			`Blockade`,
			`Blockade`,
			`Stalker`,
			`Stalker`,
			`Bailiff`,
			`Bailiff`,
			`Bailiff`,
			`Confidant`,
			`Confidant`,
			`Avoider`,
			`Avoider`,
			`Avoider`,
			`Celebrity`,
			`Celebrity`,
			`Gossiper`,
			`Gossiper`,
			`Gossiper`,
			`Unblocker`,
			`Unblocker`,
			`Unblocker`,
			`Bus Driver`,
			`Bus Driver`,
			`Chauffeur`,
			`Chauffeur`,
			`One-Shot Mass Redirector`,
			`One-Shot Mass Redirector`,
			`Bulletproof Lure`,
			`Bulletproof Lure`,
			`Mirror`,
			`Mirror`,
			`2S Multiplier`,
			`Wild Card`,
			`Wild Card`,
			`Wild Card`,
			`Broken Vanillaiser`,
			`Immobile OS Parrot`,
			`Role Vanillaizer`,
			`Role Vanillaizer`,
			`Schemer`,
			`One-Shot Day-Vigilante`,
			`One-Shot Day-Vigilante`,
			`Midnight Desperado`,
			`Midnight Desperado`,
			`Murderous Vigilante`,
			`Murderous Vigilante`,
			`Judge`,
			`Haunting Vigilante`,
			`Haunting Vigilante`,
			`Haunting Doctor`,
			`Haunting Doctor`,
			`Haunting Doctor`,
			`Gambit Vigilante`,
			`Gambit Vigilante`,
			`Gambit Vigilante`,
			`Gambit Public Cop`,
			`Gambit Public Cop`,
			`Trypophobic Townie`,
			`Trypophobic Townie`,
			`Trypophobic Townie`,
			`One-Shot Reviver`,
			`One-Shot Reviver`,
			`Substitute`,
			`Substitute`,
			`Compulsive Janitor Coroner`,
			`Compulsive Janitor Coroner`,
			`Compulsive Janitor Coroner`,
			`Grim Reaper`,
			`Grim Reaper`,
			`Hallucinator`,
			`Necromancer`,
			`Insomniac`,
			`Insomniac`,
			`Friend`,
			`Friend`,
			`Friend`,
			`Friend`,
			`Friend`,
			`Friend OS Friend Recruiter`,
			`Talkative Townie`,
			`Talkative Townie`,
			`Whisperer`,
			`Whisperer`,
			`Reserved Townie`,
			`Reserved Townie`,
			`Discard Vendor`,
			`Do-It-Yourselfer`,
			`Inheritor`,
			`Inheritor`,
			`OS Prism`,
			`Randomizer`,
			`Randomizer`,
			`Card Dealer`,
			`Pseudocider`,
			`Pseudocider`,
			`Sacrifice`,
			`Sacrifice`,
			`Magician`,
			`Solo Flip Flop`,
			`Mafia Hater`,
			`Mafia Praiser`,
			`Mafia One-Shot Day-Vigilante`,
			`Mafia Schemer`,
			`Mafia Bus Driver`,
			`Mafia Chauffeur`,
			`Mafia Confidant`,
			`Mafia Blockade`,
			`Mafia Unblocker`,
			`Mafia Insomniac`,
			`Mafia Compulsive Janitor`,
			`Mafia Compulsive Janitor Coroner`,
			`Mafia Haunting Compulsive Janitor`,
			`Mafia Secret Agent`,
			`Mafia Oracle`,
			`Mafia Compatibility Checker`,
			`Mafia Teacher`,
			`Mafia Wild Card`,
			`Mafia Detector`,
			`Mafia Mirror`,
			`Mafia OS Modposter`,
			`Mafia Whisperer`,
			`Reserved Mafia`,
			`Mafia Little Liar`,
			`Mafia Magician`,
			`Mafia Magician`,
			`Mafia Bulletproof Lure`,
			`Mafia Grim Reaper`,
			`Mafia Screamer`,
			`Mafia Psychotrooper Button`,
			`Mafia Houdini`,
			`Mafia Inheritor`,
			`Mafia Role Vanillaizer`,
			`Mafia Friend`,
			`Mafia Friend`,
			`Mafia Friend`,
			`Solo Traitor Discard Vendor`,
			`Solo Traitor Pseudocider`,
			`Solo Traitor Celebrity`,
			`Solo Traitor Gossiper`,
			`Solo Traitor Broken Vanillaiser`,
			`Solo Traitor OS Subway Recruiter`,
			`Solo Traitor Hasty Lover`,
			`Solo Talkative Traitor`,
			`Alien Contrary`,
			`Alien Contrary`,
			`Alien Friend`,
			`Alien Friend`,
			`Alien Unblocker`,
			`Alien One-Shot Reviver`,
			`Alien One-Shot Mass Redirector`,
			`Alien Bouncer`,
			`Alien Blackmailer`,
			`Alien Do-It-Yourselfer`,
			`Alien Loverboy`,
			`Alien Nightmare`,
			`Alien Card Dealer`,
			`Alien Judge`,
			`Alien OS Trainwreck`,
			`Alien OS Solar God`,
			`Alien Alien-of-all-Trades`,
			`Alien Omniscient`,
			`Solo E.T`,
			`Cultafia Leader`,
			`Gambit Cult Recruiter`,
			`Solo Inquisitor`,
			`Solo Bulletproof Duskiller`,
			`Solo Bulletproof Corrupt Queen`,
			`Solo Substitute Loner`,
			`Solo Substitute Loner`,
			`Solo Bulletproof Shadow`,
			`Solo Panther`,
			`Solo Survivor Hallucinator`,
			`Solo Survivor Pseudocider`,
			`Solo Aligner`,
			`Solo Aligner`,
			`Solo Loyal Lover`,
			`Solo Survivor Friend`,
			`Solo Pseudojester`,
			`Solo Pseudolyncher`,
			`Solo Birthday Boy`,
			`Solo Universal Usurper`,
			`Solo Universal Sympathiser`,
			`Solo Anti-Survivor`,
			`Solo Wild disCard`,
		],
		picks: [`role`],
		choices: 2,
	},
};

module.exports = {
	alignments: Object.assign(Object.create(null), alignments),
	roles: Object.assign(Object.create(null), roles),
	modifiers: Object.assign(Object.create(null), modifiers),
	themes: Object.assign(Object.create(null), themes),
	IDEAs: Object.assign(Object.create(null), IDEAs),
};
/**
	 * @param {string?} userid
	 * @return {void}
	 */
	nextSub(userid = null) {
		if (!this.subs.length || (!this.hostRequestedSub.length && ((!this.requestedSub.length || !this.autoSub)) && !userid)) return;
		const nextSub = this.subs.shift();
		if (!nextSub) return;
		const sub = Users(nextSub, true);
		if (!sub || !sub.connected || !sub.named || !this.room.users[sub.userid]) return; // should never happen, just to be safe
		const toSubOut = userid || this.hostRequestedSub.shift() || this.requestedSub.shift();
		if (!toSubOut) {
			// Should never happen
			this.subs.unshift(nextSub);
			return;
		}
		if (this.hostRequestedSub.includes(toSubOut)) this.hostRequestedSub.splice(this.hostRequestedSub.indexOf(toSubOut), 1);
		if (this.requestedSub.includes(toSubOut)) this.requestedSub.splice(this.requestedSub.indexOf(toSubOut), 1);
		this.sub(toSubOut, sub.userid);
	}

	/**
	 * @param {User} user
	 * @param {number} choices
	 * @param {string[]} picks
	 * @param {string} rolesString
	 */
	customIdeaInit(user, choices, picks, rolesString) {
		this.originalRoles = [];
		this.originalRoleString = '';
		this.roles = [];
		this.roleString = '';

		const roles = Chat.stripHTML(rolesString);
		let roleList = roles.split('\n');
		if (roleList.length === 1) {
			roleList = roles.split(',').map(r => r.trim());
		}

		this.IDEA.data = {
			name: `${this.host}'s IDEA`, // already escaped
			untrusted: true,
			roles: roleList,
			picks,
			choices,
		};
		return this.ideaDistributeRoles(user);
	}
	/**
	 *
	 * @param {User} user
	 * @param {string} moduleName
	 */
	ideaInit(user, moduleName) {
		this.originalRoles = [];
		this.originalRoleString = '';
		this.roles = [];
		this.roleString = '';

		this.IDEA.data = MafiaData.IDEAs[moduleName];
		if (typeof this.IDEA.data === 'string') this.IDEA.data = MafiaData.IDEAs[this.IDEA.data];
		if (!this.IDEA.data) return user.sendTo(this.room, `|error|${moduleName} is not a valid IDEA.`);
		if (typeof this.IDEA.data !== 'object') return this.sendRoom(`Invalid alias for IDEA ${moduleName}. Please report this to a mod.`);
		return this.ideaDistributeRoles(user);
	}

	/**
	 *
	 * @param {User} user
	 */
	ideaDistributeRoles(user) {
		if (!this.IDEA.data) return user.sendTo(this.room, `|error|No IDEA module loaded`);
		if (this.phase !== 'locked' && this.phase !== 'IDEAlocked') return user.sendTo(this.room, `|error|The game must be in a locked state to distribute IDEA roles.`);

		const neededRoles = this.IDEA.data.choices * this.playerCount;
		if (neededRoles > this.IDEA.data.roles.length) return user.sendTo(this.room, `|error|Not enough roles in the IDEA module.`);

		let roles = [];
		let selectedIndexes = [];
		for (let i = 0; i < neededRoles; i++) {
			let randomIndex;
			do {
				randomIndex = Math.floor(Math.random() * this.IDEA.data.roles.length);
			} while (selectedIndexes.indexOf(randomIndex) !== -1);
			roles.push(this.IDEA.data.roles[randomIndex]);
			selectedIndexes.push(randomIndex);
		}
		Dex.shuffle(roles);
		this.IDEA.waitingPick = [];
		for (const p in this.players) {
			const player = this.players[p];
			player.role = null;
			player.IDEA = {
				choices: roles.splice(0, this.IDEA.data.choices),
				originalChoices: [], // MAKE SURE TO SET THIS
				picks: {},
			};
			player.IDEA.originalChoices = player.IDEA.choices.slice();
			for (const pick of this.IDEA.data.picks) {
				player.IDEA.picks[pick] = null;
				this.IDEA.waitingPick.push(p);
			}
			const u = Users(p);
			// @ts-ignore guaranteed at this point
			if (u && u.connected) u.send(`>${this.room.id}\n|notify|Pick your role in the IDEA module.`);
		}

		this.phase = 'IDEApicking';
		this.updatePlayers();

		this.sendRoom(`${this.IDEA.data.name} roles have been distributed. You will have ${IDEA_TIMER / 1000} seconds to make your picks.`, {declare: true});
		this.IDEA.timer = setTimeout(() => { this.ideaFinalizePicks(); }, IDEA_TIMER);

		return ``;
	}

	/**
	 *
	 * @param {User} user
	 * @param {string[]} selection
	 */
	ideaPick(user, selection) {
		let buf = '';
		if (this.phase !== 'IDEApicking') return 'The game is not in the IDEA picking phase.';
		if (!this.IDEA || !this.IDEA.data) return this.sendRoom(`Trying to pick an IDEA role with no module running, target: ${JSON.stringify(selection)}. Please report this to a mod.`);
		const player = this.players[user.userid];
		if (!player.IDEA) return this.sendRoom(`Trying to pick an IDEA role with no player IDEA object, user: ${user.userid}. Please report this to a mod.`);
		selection = selection.map(toId);
		if (selection.length === 1 && this.IDEA.data.picks.length === 1) selection = [this.IDEA.data.picks[0], selection[0]];
		if (selection.length !== 2) return user.sendTo(this.room, `|error|Invalid selection.`);

		// input is formatted as ['selection', 'role']
		// eg: ['role', 'bloodhound']
		// ['alignment', 'alien']
		// ['selection', ''] deselects
		if (selection[1]) {
			const roleIndex = player.IDEA.choices.map(toId).indexOf(selection[1]);
			if (roleIndex === -1) return user.sendTo(this.room, `|error|${selection[1]} is not an available role, perhaps it is already selected?`);
			selection[1] = player.IDEA.choices.splice(roleIndex, 1)[0];
		} else {
			selection[1] = '';
		}

		if (player.IDEA.picks[selection[0]]) {
			buf += `You have deselected ${player.IDEA.picks[selection[0]]}. `;
			player.IDEA.choices.push(player.IDEA.picks[selection[0]]);
		}

		if (player.IDEA.picks[selection[0]] && !selection[1]) {
			this.IDEA.waitingPick.push(player.userid);
		} else if (!player.IDEA.picks[selection[0]] && selection[1]) {
			this.IDEA.waitingPick.splice(this.IDEA.waitingPick.indexOf(player.userid), 1);
		}

		player.IDEA.picks[selection[0]] = selection[1];
		if (selection[1]) buf += `You have selected ${selection[0]}: ${selection[1]}.`;
		player.updateHtmlRoom();
		if (!this.IDEA.waitingPick.length) {
			if (this.IDEA.timer) clearTimeout(this.IDEA.timer);
			this.ideaFinalizePicks();
			return;
		}
		return user.sendTo(this.room, buf);
	}

	ideaFinalizePicks() {
		if (!this.IDEA || !this.IDEA.data) return this.sendRoom(`Tried to finalize IDEA picks with no IDEA module running, please report this to a mod.`);
		let randed = [];
		for (const p in this.players) {
			const player = this.players[p];
			if (!player.IDEA) return this.sendRoom(`Trying to pick an IDEA role with no player IDEA object, user: ${player.userid}. Please report this to a mod.`);
			let randPicked = false;
			let role = [];
			for (const choice of this.IDEA.data.picks) {
				if (!player.IDEA.picks[choice]) {
					randPicked = true;
					player.IDEA.picks[choice] = player.IDEA.choices.shift();
					this.sendUser(player.userid, `You were randomly assigned ${choice}: ${player.IDEA.picks[choice]}`);
				}
				role.push(`${choice}: ${player.IDEA.picks[choice]}`);
			}
			if (randPicked) randed.push(p);
			// if there's only one option, it's their role, parse it properly
			let roleName = '';
			if (this.IDEA.data.picks.length === 1) {
				const role = MafiaTracker.parseRole(player.IDEA.picks[this.IDEA.data.picks[0]]);
				player.role = role.role;
				if (role.problems.length && !this.IDEA.data.untrusted) this.sendRoom(`Problems found when parsing IDEA role ${player.IDEA.picks[this.IDEA.data.picks[0]]}. Please report this to a mod.`);
			} else {
				roleName = role.join('; ');
				player.role = {
					name: roleName,
					safeName: Chat.escapeHTML(roleName),
					id: toId(roleName),
					alignment: 'solo',
					memo: [`(Your role was set from an IDEA.)`],
					image: '',
				};
				// hardcoding this because it makes GestI so much nicer
				if (!this.IDEA.data.untrusted) {
					for (const pick of role) {
						if (pick.substr(0, 10) === 'alignment:') {
							const parsedRole = MafiaTracker.parseRole(pick.substr(9));
							if (parsedRole.problems.length) this.sendRoom(`Problems found when parsing IDEA role ${pick}. Please report this to a mod.`);
							player.role.alignment = parsedRole.role.alignment;
						}
					}
				}
			}
		}
		this.IDEA.discardsHtml = `<b>Discards:</b><br />`;
		for (const p of Object.keys(this.players).sort()) {
			const IDEA = this.players[p].IDEA;
			if (!IDEA) return this.sendRoom(`No IDEA data for player ${p} when finalising IDEAs. Please report this to a mod.`);
			this.IDEA.discardsHtml += `<b>${this.players[p].safeName}:</b> ${IDEA.choices.join(', ')}<br />`;
		}

		this.phase = 'IDEAlocked';
		if (randed.length) this.sendRoom(`${randed.join(', ')} did not pick a role in time and were randomly assigned one.`, {declare: true});
		this.sendRoom(`IDEA picks are locked!`, {declare: true});
		this.sendRoom(`To start, use /mafia start, or to reroll use /mafia ideareroll`);
		this.updatePlayers();
	}

	/**
	 * @return {void}
	 */
	sendPlayerList() {
		this.room.add(`|c:|${(Math.floor(Date.now() / 1000))}|~|**Players (${this.playerCount})**: ${Object.keys(this.players).map(p => this.players[p].name).join(', ')}`).update();
	}

	/**
	 * @return {void}
	 */
	updatePlayers() {
		for (const p in this.players) {
			this.players[p].updateHtmlRoom();
		}
		for (const p in this.dead) {
			if (this.dead[p].restless || this.dead[p].treestump) this.dead[p].updateHtmlRoom();
		}
		// Now do the host
		this.updateHost();
	}

	/**
	 * @return {void}
	 */
	updateHost() {
		for (const hostid of [...this.cohosts, this.hostid]) {
			const host = Users(hostid);
			if (!host || !host.connected) return;
			if (this.ended) return host.send(`>view-mafia-${this.room.id}\n|deinit`);
			// @ts-ignore
			const buf = Chat.pages.mafia([this.room.id], host);
			host.send(`>view-mafia-${this.room.id}\n|init|html\n${buf}`);
		}
	}

	/**
	 * @return {void}
	 */
	updateRoleString() {
		this.roleString = this.roles.slice().map(r => `<span style="font-weight:bold;color:${MafiaData.alignments[r.alignment].color || '#FFF'}">${r.safeName}</span>`).join(', ');
	}

	/**
	 * @param {string} message
	 * @param {{uhtml?: boolean, declare?: boolean, strong?: boolean, timestamp?: boolean}} options
	 * @return {void}
	 */
	sendRoom(message, options = {}) {
		if (options.uhtml) return this.room.add(`|uhtml|mafia|${message}`).update();
		if (options.declare) return this.room.add(`|raw|<div class="broadcast-blue">${message}</div>`).update();
		if (options.strong) return this.room.add(`|raw|<strong>${message}</strong>`).update();
		if (options.timestamp) return this.room.add(`|c:|${(Math.floor(Date.now() / 1000))}|~|${message}`).update();
		return this.room.add(message).update();
	}

	/**
	 * @return {string}
	 */
	roomWindow() {
		if (this.ended) return `<div class="infobox">The game of ${this.title} has ended.</div>`;
		let output = `<div class="broadcast-blue">`;
		if (this.phase === 'signups') {
			output += `<h2 style="text-align: center">A game of ${this.title} was created</h2><p style="text-align: center"><button class="button" name="send" value="/mafia join">Join the game</button> <button class="button" name="send" value="/join view-mafia-${this.room.id}">Spectate the game</button> <button class="button" name="send" value="/help mafia">Mafia Commands</button></p>`;
		} else {
			output += `<p style="font-weight: bold">A game of ${this.title} is in progress.</p><p><button class="button" name="send" value="/mafia sub ${this.room.id}, in">Become a substitute</button> <button class="button" name="send" value="/join view-mafia-${this.room.id}">Spectate the game</button> <button class="button" name="send" value="/help mafia">Mafia Commands</button></p>`;
		}
		output += `</div>`;
		return output;
	}

	/**
	 * @param {User} user
	 * @param {boolean} self
	 * @param {boolean} force
	 */
	canJoin(user, self = false, force = false) {
		if (!user || !user.connected) return `User not found.`;
		const targetString = self ? `You are` : `${user.userid} is`;
		if (!this.room.users[user.userid]) return `${targetString} not in the room.`;
		if (this.players[user.userid]) return `${targetString} already in the game.`;
		if (this.hostid === user.userid) return `${targetString} the host.`;
		if (this.cohosts.includes(user.userid)) return `${targetString} a cohost.`;
		if (!force) {
			for (const alt of user.getAltUsers(true)) {
				if (this.players[alt.userid] || this.played.includes(alt.userid)) return `${self ? `You already have` : `${user.userid} already has`} an alt in the game.`;
				if (this.hostid === alt.userid || this.cohosts.includes(alt.userid)) return `${self ? `You have` : `${user.userid} has`} an alt as a game host.`;
			}
		}
		return false;
	}

	/**
	 * @param {User | string | null} user
	 * @param {string} message
	 */
	sendUser(user, message) {
		const userObject = (typeof user === 'string' ? Users(user) : user);
		if (!userObject || !userObject.connected) return;
		userObject.sendTo(this.room, message);
	}

	/**
	 * @param {User} user
	 * @param {boolean | 'hammer'} setting
	 */
	setSelfLynch(user, setting) {
		const from = this.selfEnabled;
		if (from === setting) return user.sendTo(this.room, `|error|Selflynching is already ${setting ? `set to Self${setting === 'hammer' ? 'hammering' : 'lynching'}` : 'disabled'}.`);
		if (from) {
			this.sendRoom(`Self${from === 'hammer' ? 'hammering' : 'lynching'} has been ${setting ? `changed to Self${setting === 'hammer' ? 'hammering' : 'lynching'}` : 'disabled'}.`, {declare: true});
		} else {
			this.sendRoom(`Self${setting === 'hammer' ? 'hammering' : 'lynching'} has been ${setting ? 'enabled' : 'disabled'}.`, {declare: true});
		}
		this.selfEnabled = setting;
		if (!setting) {
			for (const player of Object.values(this.players)) {
				if (player.lynching === player.userid) this.unlynch(player.userid, true);
			}
		}
		this.updatePlayers();
	}
	/**
	 * @param {User} user
	 * @param {boolean} setting
	 */
	setNoLynch(user, setting) {
		if (this.enableNL === setting) return user.sendTo(this.room, `|error|No Lynch is already ${setting ? 'enabled' : 'disabled'}.`);
		this.enableNL = setting;
		this.sendRoom(`No Lynch has been ${setting ? 'enabled' : 'disabled'}.`, {declare: true});
		if (!setting) this.clearLynches('nolynch');
		this.updatePlayers();
	}
	/**
	 * @param {string} target
	 */
	clearLynches(target = '') {
		if (target) delete this.lynches[target];
		for (const player of Object.values(this.players)) {
			if (!target || (player.lynching === target)) player.lynching = '';
		}
		for (const player of Object.values(this.dead)) {
			if (player.restless && (!target || player.lynching === target)) player.lynching = '';
		}
		this.hasPlurality = null;
	}

	/**
	 * @param {string} message
	 * @param {User} user
	 * @return {(string | false)}
	 */
	onChatMessage(message, user) {
		const subIndex = this.hostRequestedSub.indexOf(user.userid);
		if (subIndex !== -1) {
			this.hostRequestedSub.splice(subIndex, 1);
			for (const hostid of [...this.cohosts, this.hostid]) {
				this.sendUser(hostid, `${user.userid} has spoken and been removed from the host sublist.`);
			}
		}

		if (user.isStaff || (this.room.auth && this.room.auth[user.userid] && this.room.auth[user.userid] !== '+') || this.hostid === user.userid || this.cohosts.includes(user.userid) || !this.started) return false;
		if (!this.players[user.userid] && (!this.dead[user.userid] || !this.dead[user.userid].treestump)) return `You cannot talk while a game of ${this.title} is going on.`;
		if (this.phase === 'night') return `You cannot talk at night.`;
		return false;
	}

	/**
	 * @param {User} user
	 * @return {void}
	 */
	onConnect(user) {
		user.sendTo(this.room, `|uhtml|mafia|${this.roomWindow()}`);
	}

	/**
	 * @param {User} user
	 * @return {void}
	 */
	onJoin(user) {
		if (user.userid in this.players) {
			return this.players[user.userid].updateHtmlRoom();
		}
		if (user.userid === this.hostid) return this.updateHost();
	}

	/**
	 * @param {User} user
	 * @return {void}
	 */
	onLeave(user) {
		if (this.subs.includes(user.userid)) this.subs.splice(this.subs.indexOf(user.userid), 1);
	}

	/**
	 * @param {User} user
	 * @return {void}
	 */
	removeBannedUser(user) {
		// Player was banned, attempt to sub now
		// If we can't sub now, make subbing them out the top priority
		if (!(user.userid in this.players)) return;
		this.requestedSub.unshift(user.userid);
		this.nextSub();
	}

	/**
	 * @param {User} user
	 * @return {void}
	 */
	forfeit(user) {
		// Add the player to the sub list.
		if (!(user.userid in this.players)) return;
		this.requestedSub.push(user.userid);
		this.nextSub();
	}

	/**
	 * @return {void}
	 */
	end() {
		this.ended = true;
		this.sendRoom(this.roomWindow(), {uhtml: true});
		this.updatePlayers();
		if (this.room.id === 'mafia' && this.started) {
			// Intead of using this.played, which shows players who have subbed out as well
			// We check who played through to the end when recording playlogs
			const played = Object.keys(this.players).concat(Object.keys(this.dead));
			const month = new Date().toLocaleString("en-us", {month: "numeric", year: "numeric"});
			if (!logs.plays[month]) logs.plays[month] = {};
			for (const player of played) {
				if (!logs.plays[month][player]) logs.plays[month][player] = 0;
				logs.plays[month][player]++;
			}
			if (!logs.hosts[month]) logs.hosts[month] = {};
			for (const hostid of [...this.cohosts, this.hostid]) {
				if (!logs.hosts[month][hostid]) logs.hosts[month][hostid] = 0;
				logs.hosts[month][hostid]++;
			}
			writeFile(LOGS_FILE, logs);
		}
		if (this.timer) {
			clearTimeout(this.timer);
			this.timer = null;
		}
		this.destroy();
	}

	destroy() {
		// Slightly modified to handle dead players
		if (this.timer) clearTimeout(this.timer);
		if (this.IDEA.timer) clearTimeout(this.IDEA.timer);
		this.room.game = null;
		this.room = /** @type {any} */ (null);
		for (let i in this.players) {
			this.players[i].destroy();
		}
		for (let i in this.dead) {
			this.dead[i].destroy();
		}
	}
}

/** @type {PageTable} */
const pages = {
	mafia: function (query, user) {
		if (!user.named) return Rooms.RETRY_AFTER_LOGIN;
		if (!query.length) return `|deinit`;
		let roomid = query.shift();
		if (roomid === 'groupchat') roomid += `-${query.shift()}-${query.shift()}`;
		const room = /** @type {ChatRoom} */ (Rooms(roomid));
		if (!room || !room.users[user.userid] || !room.game || room.game.gameid !== 'mafia' || room.game.ended) return `|deinit`;
		const game = /** @type {MafiaTracker} */ (room.game);
		const isPlayer = user.userid in game.players;
		const isHost = user.userid === game.hostid || game.cohosts.includes(user.userid);
		let buf = `|title|${game.title}\n|pagehtml|<div class="pad broadcast-blue">`;
		buf += `<button class="button" name="send" value="/join view-mafia-${room.id}" style="float:left"><i class="fa fa-refresh"></i> Refresh</button>`;
		buf += `<br/><br/><h1 style="text-align:center;">${game.title}</h1><h3>Host: ${game.host}</h3>`;
		buf += `<p style="font-weight:bold;">Players (${game.playerCount}): ${Object.keys(game.players).sort().map(p => game.players[p].safeName).join(', ')}</p><hr/>`;
		if (isPlayer && game.phase === 'IDEApicking') {
			buf += `<p><b>IDEA information:</b><br />`;
			const IDEA = game.players[user.userid].IDEA;
			if (!IDEA) return game.sendRoom(`IDEA picking phase but no IDEA object for user: ${user.userid}. Please report this to a mod.`);
			for (const pick of Object.keys(IDEA.picks)) {
				buf += `<b>${pick}:</b> `;
				if (!IDEA.picks[pick]) {
					buf += `<button class="button disabled" style="font-weight:bold; color:#575757; font-weight:bold; background-color:#d3d3d3;">clear</button>`;
				} else {
					buf += `<button class="button" name="send" value="/mafia ideapick ${roomid}, ${pick},">clear</button>`;
				}
				const selectedIndex = IDEA.picks[pick] ? IDEA.originalChoices.indexOf(IDEA.picks[pick]) : -1;
				for (let i = 0; i < IDEA.originalChoices.length; i++) {
					const choice = IDEA.originalChoices[i];
					if (i === selectedIndex) {
						buf += `<button class="button disabled" style="font-weight:bold; color:#575757; font-weight:bold; background-color:#d3d3d3;">${choice}</button>`;
					} else {
						buf += `<button class="button" name="send" value="/mafia ideapick ${roomid}, ${pick}, ${toId(choice)}">${choice}</button>`;
					}
				}
				buf += `<br />`;
			}
			buf += `</p>`;
			buf += `<p><details><summary class="button" style="display:inline-block"><b>Role details:</b></summary><p>`;
			for (const role of IDEA.originalChoices) {
				const roleObject = MafiaTracker.parseRole(role).role;
				buf += `<details><summary>${role}</summary>`;
				buf += `<table><tr><td style="text-align:center;"><td style="text-align:left;width:100%"><ul>${roleObject.memo.map(m => `<li>${m}</li>`).join('')}</ul></td></tr></table>`;
				buf += `</details>`;
			}
			buf += `</p></details></p>`;
		}
		if (game.IDEA.data) {
			buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">${game.IDEA.data.name} information</summary>`;
			if (game.IDEA.discardsHtml) buf += `<details><summary class="button" style="text-align:left; display:inline-block">Discards:</summary><p>${game.IDEA.discardsHtml}</p></details>`;
			buf += `<details><summary class="button" style="text-align:left; display:inline-block">Role list</summary><p>${game.IDEA.data.roles.join('<br />')}</p></details>`;
			buf += `</details></p>`;
		} else {
			if (!game.closedSetup) {
				if (game.theme) {
					buf += `<p><span style="font-weight:bold;">Theme</span>: ${game.theme.name}</p>`;
					buf += `<p>${game.theme.desc}</p>`;
				}
				if (game.noReveal) {
					buf += `<p><span style="font-weight:bold;">Original Rolelist</span>: ${game.originalRoleString}</p>`;
				} else {
					buf += `<p><span style="font-weight:bold;">Rolelist</span>: ${game.roleString}</p>`;
				}
			}
		}
		if (isPlayer) {
			const role = game.players[user.userid].role;
			if (role) {
				buf += `<h3>${game.players[user.userid].safeName}, you are a ${game.players[user.userid].getRole()}</h3>`;
				if (!['town', 'solo'].includes(role.alignment)) buf += `<p><span style="font-weight:bold">Partners</span>: ${game.getPartners(role.alignment, game.players[user.userid])}</p>`;
				buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">Role Details</summary>`;
				buf += `<table><tr><td style="text-align:center;">${role.image || `<img width="75" height="75" src="//play.pokemonshowdown.com/fx/mafia-villager.png"/>`}</td><td style="text-align:left;width:100%"><ul>${role.memo.map(m => `<li>${m}</li>`).join('')}</ul></td></tr></table>`;
				buf += `</details></p>`;
			}
		}
		if (game.phase === "day") {
			buf += `<h3>Lynches (Hammer: ${game.hammerCount}) <button class="button" name="send" value="/join view-mafia-${room.id}"><i class="fa fa-refresh"></i> Refresh</button></h3>`;
			let plur = game.getPlurality();
			for (const key of Object.keys(game.players).concat((game.enableNL ? ['nolynch'] : []))) {
				if (game.lynches[key]) {
					buf += `<p style="font-weight:bold">${game.lynches[key].count}${plur === key ? '*' : ''} ${game.players[key] ? game.players[key].safeName : 'No Lynch'} (${game.lynches[key].lynchers.map(a => game.players[a] ? game.players[a].safeName : a).join(', ')}) `;
				} else {
					buf += `<p style="font-weight:bold">0 ${game.players[key] ? game.players[key].safeName : 'No Lynch'} `;
				}
				const isSpirit = (game.dead[user.userid] && game.dead[user.userid].restless);
				if (isPlayer || isSpirit) {
					if (isPlayer && game.players[user.userid].lynching === key || isSpirit && game.dead[user.userid].lynching === key) {
						buf += `<button class="button" name="send" value="/mafia unlynch ${room.id}">Unlynch ${game.players[key] ? game.players[key].safeName : 'No Lynch'}</button>`;
					} else if ((game.selfEnabled && !isSpirit) || user.userid !== key) {
						buf += `<button class="button" name="send" value="/mafia lynch ${room.id}, ${key}">Lynch ${game.players[key] ? game.players[key].safeName : 'No Lynch'}</button>`;
					}
				} else if (isHost) {
					const lynch = game.lynches[key];
					if (lynch && lynch.count !== lynch.trueCount) buf += `(${lynch.trueCount})`;
					if (game.hammerModifiers[key]) buf += `(${game.getHammerValue(key)} to hammer)`;
				}
				buf += `</p>`;
			}
		} else if (game.phase === "night" && isPlayer) {
			buf += `<p style="font-weight:bold;">PM the host (${game.host}) the action you want to use tonight, and who you want to use it on. Or PM the host "idle".</p>`;
		}
		if (isHost) {
			buf += `<h3>Host options</h3>`;
			buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">General Options</summary>`;
			buf += `<h3>General Options</h3>`;
			if (!game.started) {
				buf += `<button class="button" name="send" value="/mafia closedsetup ${room.id}, ${game.closedSetup ? 'off' : 'on'}">${game.closedSetup ? 'Disable' : 'Enable'} Closed Setup</button>`;
				if (game.phase === 'locked' || game.phase === 'IDEAlocked') {
					buf += ` <button class="button" name="send" value="/mafia start ${room.id}">Start Game</button>`;
				} else {
					buf += ` <button class="button" name="send" value="/mafia close ${room.id}">Close Signups</button>`;
				}
			} else if (game.phase === 'day') {
				buf += `<button class="button" name="send" value="/mafia night ${room.id}">Go to Night ${game.dayNum}</button>`;
			} else if (game.phase === 'night') {
				buf += `<button class="button" name="send" value="/mafia day ${room.id}">Go to Day ${game.dayNum + 1}</button> <button class="button" name="send" value="/mafia extend ${room.id}">Return to Day ${game.dayNum}</button>`;
			}
			buf += ` <button class="button" name="send" value="/mafia selflynch ${room.id}, ${game.selfEnabled === true ? 'off' : 'on'}">${game.selfEnabled === true ? 'Disable' : 'Enable'} self lynching</button> `;
			buf += `<button class="button" name="send" value="/mafia ${game.enableNL ? 'disable' : 'enable'}nl ${room.id}">${game.enableNL ? 'Disable' : 'Enable'} No Lynch</button> `;
			buf += `<button class="button" name="send" value="/mafia reveal ${room.id}, ${game.noReveal ? 'on' : 'off'}">${game.noReveal ? 'Enable' : 'Disable'} revealing of roles</button> `;
			buf += `<button class="button" name="send" value="/mafia autosub ${room.id}, ${game.autoSub ? 'off' : 'on'}">${game.autoSub ? "Disable" : "Enable"} automatic subbing of players</button> `;
			buf += `<button class="button" name="send" value="/mafia end ${room.id}">End Game</button>`;
			buf += `<p>To set a deadline, use <strong>/mafia deadline [minutes]</strong>.<br />To clear the deadline use <strong>/mafia deadline off</strong>.</p><hr/></details></p>`;
			buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">Player Options</summary>`;
			buf += `<h3>Player Options</h3>`;
			for (let p in game.players) {
				let player = game.players[p];
				buf += `<p><details><summary class="button" style="text-align:left; display:inline-block"><span style="font-weight:bold;">`;
				buf += `${player.safeName} (${player.role ? player.getRole(true) : ''})${game.lynchModifiers[p] !== undefined ? `(lynches worth ${game.getLynchValue(p)})` : ''}</summary>`;
				buf += `<button class="button" name="send" value="/mafia kill ${room.id}, ${player.userid}">Kill</button> `;
				buf += `<button class="button" name="send" value="/mafia treestump ${room.id}, ${player.userid}">Make a Treestump (Kill)</button> `;
				buf += `<button class="button" name="send" value="/mafia spirit ${room.id}, ${player.userid}">Make a Restless Spirit (Kill)</button> `;
				buf += `<button class="button" name="send" value="/mafia spiritstump ${room.id}, ${player.userid}">Make a Restless Treestump (Kill)</button> `;
				buf += `<button class="button" name="send" value="/mafia sub ${room.id}, next, ${player.userid}">Force sub</button></span></details></p>`;
			}
			for (let d in game.dead) {
				let dead = game.dead[d];
				buf += `<p style="font-weight:bold;">${dead.safeName} (${dead.role ? dead.getRole() : ''})`;
				if (dead.treestump) buf += ` (is a Treestump)`;
				if (dead.restless) buf += ` (is a Restless Spirit)`;
				if (game.lynchModifiers[d] !== undefined) buf += ` (lynches worth ${game.getLynchValue(d)})`;
				buf += `: <button class="button" name="send" value="/mafia revive ${room.id}, ${dead.userid}">Revive</button></p>`;
			}
			buf += `<hr/></details></p>`;
			buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">How to setup roles</summary>`;
			buf += `<h3>Setting the roles</h3>`;
			buf += `<p>To set the roles, use /mafia setroles [comma seperated list of roles] OR /mafia setroles [theme] in ${room.title}.</p>`;
			buf += `<p>If you set the roles from a theme, the role parser will get all the correct roles for you. (Not all themes are supported).</p>`;
			buf += `<p>The following key words determine a role's alignment (If none are found, the default alignment is town):</p>`;
			buf += `<p style="font-weight:bold">${Object.keys(MafiaData.alignments).map(a => `<span style="color:${MafiaData.alignments[a].color || '#FFF'}">${MafiaData.alignments[a].name}</span>`).join(', ')}</p>`;
			buf += `<p>Please note that anything inside (parentheses) is ignored by the role parser.</p>`;
			buf += `<p>If you have roles that have conflicting alignments or base roles, you can use /mafia forcesetroles [comma seperated list of roles] to forcibly set the roles.</p>`;
			buf += `<p>Please note that you will have to PM all the players their alignment, partners (if any), and other information about their role because the server will not provide it.</p>`;
			buf += `<hr/></details></p>`;
			buf += `<p style="font-weight:bold;">Players who will be subbed unless they talk: ${game.hostRequestedSub.join(', ')}</p>`;
			buf += `<p style="font-weight:bold;">Players who are requesting a sub: ${game.requestedSub.join(', ')}</p>`;
		}
		buf += `<p style="font-weight:bold;">Sub List: ${game.subs.join(', ')}</p>`;
		if (!isHost) {
			if (game.phase === 'signups') {
				if (isPlayer) {
					buf += `<p><button class="button" name="send" value="/mafia leave ${room.id}">Leave game</button></p>`;
				} else {
					buf += `<p><button class="button" name="send" value="/mafia join ${room.id}">Join game</button></p>`;
				}
			} else if ((!isPlayer && game.subs.includes(user.userid)) || (isPlayer && !game.requestedSub.includes(user.userid))) {
				buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">${isPlayer ? 'Request to be subbed out' : 'Cancel sub request'}</summary>`;
				buf += `<button class="button" name="send" value="/mafia sub ${room.id}, out">${isPlayer ? 'Confirm request to be subbed out' : 'Confirm cancelation of sub request'}</button></details></p>`;
			} else {
				buf += `<p><details><summary class="button" style="text-align:left; display:inline-block">${isPlayer ? 'Cancel sub request' : 'Join the game as a sub'}</summary>`;
				buf += `<button class="button" name="send" value="/mafia sub ${room.id}, in">${isPlayer ? 'Confirm cancelation of sub request' : 'Confirm that you want to join the game'}</button></details></p>`;
			}
		}
		buf += `</div>`;
		return buf;
	},
	mafialadder: function (query, user) {
		if (!user.named) return Rooms.RETRY_AFTER_LOGIN;
		if (!query.length || !Rooms('mafia')) return `|deinit`;
		/** @type {{[k: string]: {title: string, type: string, section: MafiaLogSection}}} */
		const headers = {
			leaderboard: {title: 'Leaderboard', type: 'Points', section: 'leaderboard'},
			mvpladder: {title: 'MVP Ladder', type: 'MVPs', section: 'mvps'},
			hostlogs: {title: 'Host Logs', type: 'Hosts', section: 'hosts'},
			playlogs: {title: 'Play Logs', type: 'Plays', section: 'plays'},
			leaverlogs: {title: 'Leaver Logs', type: 'Leavers', section: 'leavers'},
		};
		let date = new Date();
		if (query[1] === 'prev') date.setMonth(date.getMonth() - 1);
		const month = date.toLocaleString("en-us", {month: "numeric", year: "numeric"});
		const ladder = headers[query[0]];
		if (!ladder) return `|deinit`;
		const mafiaRoom = /** @type {ChatRoom?} */ (Rooms('mafia'));
		if (['hosts', 'plays', 'leavers'].includes(ladder.section) && !user.can('mute', null, mafiaRoom)) return `|deinit`;
		let buf = `|title|Mafia ${ladder.title} (${date.toLocaleString("en-us", {month: 'long'})} ${date.getFullYear()})\n|pagehtml|<div class="pad ladder">`;
		buf += `${query[1] === 'prev' ? '' : `<button class="button" name="send" value="/join view-mafialadder-${query[0]}" style="float:left"><i class="fa fa-refresh"></i> Refresh</button> <button class="button" name="send" value="/join view-mafialadder-${query[0]}-prev" style="float:left">View last month's ${ladder.title}</button>`}`;
		buf += `<br /><br />`;
		const section = ladder.section;
		if (!logs[section][month] || !Object.keys(logs[section][month]).length) {
			buf += `${ladder.title} for ${date.toLocaleString("en-us", {month: 'long'})} ${date.getFullYear()} not found.</div>`;
			return buf;
		}
		const keys = Object.keys(logs[section][month]).sort((keyA, keyB) => {
			const a = logs[section][month][keyA];
			const b = logs[section][month][keyB];
			return b - a;
		});
		buf += `<table style="margin-left: auto; margin-right: auto"><tbody><tr><th colspan="2"><h2 style="margin: 5px auto">Mafia ${ladder.title} for ${date.toLocaleString("en-us", {month: 'long'})} ${date.getFullYear()}</h1></th></tr>`;
		buf += `<tr><th>User</th><th>${ladder.type}</th></tr>`;
		for (const key of keys) {
			buf += `<tr><td>${key}</td><td>${logs[section][month][key]}</td></tr>`;
		}
		return buf + `</table></div>`;
	},
};

/** @type {ChatCommands} */
const commands = {
	mafia: {
		'': function (target, room, user) {
			const game = /** @type {MafiaTracker?} */ (room.game);
			if (game && game.gameid === 'mafia') {
				if (!this.runBroadcast()) return;
				return this.sendReply(`|html|${game.roomWindow()}`);
			}
			return this.parse('/help mafia');
		},

		forcehost: 'host',
		nexthost: 'host',
		host: function (target, room, user, connection, cmd) {
			if (!room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (!this.canTalk()) return;
			if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
			if (room.game) return this.errorReply(`There is already a game of ${room.game.title} in progress in this room.`);
			if (!user.can('broadcast', null, room)) return this.errorReply(`/mafia ${cmd} - Access denied.`);

			let nextHost = false;
			if (room.id === 'mafia') {
				if (cmd === 'nexthost') {
					nextHost = true;
					if (!hostQueue.length) return this.errorReply(`Nobody is on the host queue.`);
					let skipped = [];
					do {
						// @ts-ignore guaranteed
						this.splitTarget(hostQueue.shift(), true);
						if (!this.targetUser || !this.targetUser.connected || !room.users[this.targetUser.userid] || isHostBanned(this.targetUser.userid)) {
							skipped.push(this.targetUsername);
							this.targetUser = null;
						}
					} while (!this.targetUser && hostQueue.length);
					if (skipped.length) this.sendReply(`${skipped.join(', ')} ${Chat.plural(skipped.length, 'were', 'was')} not online, not in the room, or are host banned and were removed from the host queue.`);
					if (!this.targetUser) return this.errorReply(`Nobody on the host queue could be hosted.`);
				} else {
					if (cmd !== 'forcehost' && hostQueue.length && toId(target) !== hostQueue[0]) return this.errorReply(`${target} is not next on the host queue. To host them now anyways, use /mafia forcehost ${target}`);
					this.splitTarget(target, true);
				}
			} else {
				this.splitTarget(target, true);
			}

			if (!this.targetUser || !this.targetUser.connected) return this.errorReply(`The user "${this.targetUsername}" was not found.`);
			if (!nextHost && this.targetUser.userid !== user.userid && !this.can('mute', null, room)) return false;
			if (!room.users[this.targetUser.userid]) return this.errorReply(`${this.targetUser.name} is not in this room, and cannot be hosted.`);
			if (room.id === 'mafia' && isHostBanned(this.targetUser.userid)) return this.errorReply(`${this.targetUser.name} is banned from hosting games.`);

			let targetUser = this.targetUser;

			room.game = new MafiaTracker(room, targetUser);

			// @ts-ignore
			targetUser.send(`>view-mafia-${room.id}\n|init|html\n${Chat.pages.mafia([room.id], targetUser)}`);
			room.addByUser(user, `${targetUser.name} was appointed the mafia host by ${user.name}.`);
			if (room.id === 'mafia') {
				const queueIndex = hostQueue.indexOf(targetUser.userid);
				if (queueIndex > -1) hostQueue.splice(queueIndex, 1);
				room.add(`|c:|${(Math.floor(Date.now() / 1000))}|~|**Mafiasignup!**`).update();
			}
			this.modlog('MAFIAHOST', targetUser, null, {noalts: true, noip: true});
		},
		hosthelp: [
			`/mafia host [user] - Create a game of Mafia with [user] as the host. Requires + % @ $ * # & ~, voices can only host themselves`,
		],

		q: 'queue',
		queue: function (target, room, user) {
			if (!room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (room.id !== 'mafia') return this.errorReply(`This command can only be used in the Mafia room.`);
			const args = target.split(',').map(toId);
			if (['forceadd', 'add', 'remove', 'del', 'delete'].includes(args[0])) {
				const permission = (user.userid === args[1]) ? 'broadcast' : 'mute';
				if (['forceadd', 'add'].includes(args[0]) && !this.can(permission, null, room)) return;
				if (['remove', 'del', 'delete'].includes(args[0]) && user.userid !== args[1] && !this.can('mute', null, room)) return;
			} else {
				if (!this.runBroadcast()) return false;
			}
			switch (args[0]) {
			case 'forceadd':
			case 'add':
				if (!this.canTalk()) return;
				let targetUser = Users(args[1]);
				if ((!targetUser || !targetUser.connected) && args[0] !== 'forceadd') return this.errorReply(`User ${args[1]} not found. To forcefully add the user to the queue, use /mafia queue forceadd, ${args[1]}`);
				if (hostQueue.includes(args[1])) return this.errorReply(`User ${args[1]} is already on the host queue.`);
				if (isHostBanned(args[1])) return this.errorReply(`User ${args[1]} is banned from hosting games.`);
				hostQueue.push(args[1]);
				room.add(`User ${args[1]} has been added to the host queue by ${user.name}.`).update();
				break;
			case 'del':
			case 'delete':
			case 'remove':
				let index = hostQueue.indexOf(args[1]);
				if (index === -1) return this.errorReply(`User ${args[1]} is not on the host queue.`);
				hostQueue.splice(index, 1);
				room.add(`User ${args[1]} has been removed from the host queue by ${user.name}.`).update();
				break;
			case '':
			case 'show':
			case 'view':
				this.sendReplyBox(`<strong>Host Queue:</strong> ${hostQueue.join(', ')}`);
				break;
			default:
				this.parse('/help mafia queue');
			}
		},
		queuehelp: [
			`/mafia queue - Shows the upcoming users who are going to host.`,
			`/mafia queue add, (user) - Adds the user to the hosting queue. Requires: + % @ $ # & ~`,
			`/mafia queue remove, (user) - Removes the user from the hosting queue. Requires: + % @ $ # & ~`,
		],

		qadd: 'queueadd',
		qforceadd: 'queueadd',
		queueforceadd: 'queueadd',
		queueadd: function (target, room, user, connection, cmd) {
			this.parse(`/mafia queue ${cmd.includes('force') ? `forceadd` : `add`}, ${target}`);
		},

		qdel: 'queueremove',
		qdelete: 'queueremove',
		qremove: 'queueremove',
		queueremove: function (target, room, user) {
			this.parse(`/mafia queue remove, ${target}`);
		},

		'!mafjoin': true,
		// Typescript doesn't like "join" as the command name for some reason, so this is a hack to get around that.
		join: 'mafjoin',
		mafjoin: function (target, room, user) {
			let targetRoom = /** @type {ChatRoom} */ (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);

			if (!this.canTalk(null, targetRoom)) return;
			game.join(user);
		},
		joinhelp: [`/mafia join - Join the game.`],

		'!leave': true,
		leave: function (target, room, user) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			game.leave(user);
		},
		leavehelp: [`/mafia leave - Leave the game. Can only be done while signups are open.`],

		playercap: function (target, room, user) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (game.phase !== 'signups') return this.errorReply(`Signups are already closed.`);
			if (toId(target) === 'none') target = '20';
			const num = parseInt(target);
			if (isNaN(num) || num > 20 || num < 2) return this.parse('/help mafia playercap');
			if (num < game.playerCount) return this.errorReply(`Player cap has to be equal or more than the amount of players in game.`);
			if (num === game.playerCap) return this.errorReply(`Player cap is already set at ${game.playerCap}.`);
			game.playerCap = num;
			game.sendRoom(`Player cap has been set to ${game.playerCap}`, {declare: true});
		},
		playercaphelp: [`/mafia playercap [cap|none]- Limit the number of players being able to join the game. Player cap cannot be more than 20 or less than 2. Requires: host % @ $ # & ~`],

		'!close': true,
		close: function (target, room, user) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (game.phase !== 'signups') return user.sendTo(targetRoom, `|error|Signups are already closed.`);
			if (game.playerCount < 2) return user.sendTo(targetRoom, `|error|You need at least 2 players to start.`);
			game.phase = 'locked';
			game.sendRoom(game.roomWindow(), {uhtml: true});
			game.updatePlayers();
		},
		closehelp: [`/mafia close - Closes signups for the current game. Requires: host % @ $ * # & ~`],

		'!closedsetup': true,
		cs: 'closedsetup',
		closedsetup: function (target, room, user) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			const action = toId(args.join(''));
			if (!['on', 'off'].includes(action)) return this.parse('/help mafia closedsetup');
			if (game.started) return user.sendTo(targetRoom, `|error|You can't ${action === 'on' ? 'enable' : 'disable'} closed setup because the game has already started.`);
			if ((action === 'on' && game.closedSetup) || (action === 'off' && !game.closedSetup)) return user.sendTo(targetRoom, `|error|Closed setup is already ${game.closedSetup ? 'enabled' : 'disabled'}.`);
			game.closedSetup = action === 'on';
			game.updateHost();
		},
		closedsetuphelp: [`/mafia closedsetup [on|off] - Sets if the game is a closed setup. Closed setups don't show the role list to players. Requires host % @ $ * # & ~`],

		'!reveal': true,
		reveal: function (target, room, user) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			const action = toId(args.join(''));
			if (!['on', 'off'].includes(action)) return this.parse('/help mafia reveal');
			if ((action === 'off' && game.noReveal) || (action === 'on' && !game.noReveal)) return user.sendTo(targetRoom, `|error|Revealing of roles is already ${game.noReveal ? 'disabled' : 'enabled'}.`);
			game.noReveal = action === 'off';
			game.sendRoom(`Revealing of roles has been ${action === 'off' ? 'disabled' : 'enabled'}.`, {declare: true});
			game.updatePlayers();
		},
		revealhelp: [`/mafia reveal [on|off] - Sets if roles reveal on death or not. Requires host % @ $ * # & ~`],

		resetroles: 'setroles',
		forceresetroles: 'setroles',
		forcesetroles: 'setroles',
		setroles: function (target, room, user, connection, cmd) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			const reset = cmd.includes('reset');
			if (reset) {
				if (game.phase !== 'day' && game.phase !== 'night') return this.errorReply(`The game has not started yet.`);
			} else {
				if (game.phase !== 'locked' && game.phase !== 'IDEAlocked') return this.errorReply(game.phase === 'signups' ? `You need to close signups first.` : `The game has already started.`);
			}
			if (!target) return this.parse('/help mafia setroles');

			game.setRoles(user, target, cmd.includes('force'), reset);
		},
		setroleshelp: [
			`/mafia setroles [comma separated roles] - Set the roles for a game of mafia. You need to provide one role per player.`,
			`/mafia forcesetroles [comma separated roles] - Forcibly set the roles for a game of mafia. No role PM information or alignment will be set.`,
			`/mafia resetroles [comma separated roles] - Reset the roles in an ongoing game.`,
		],

		idea: function (target, room, user) {
			if (!room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (!user.can('broadcast', null, room) || (!user.can('mute', null, room) && game.hostid !== user.userid && !game.cohosts.includes(user.userid))) return this.errorReply(`/mafia idea - Access denied.`);
			if (game.started) return this.errorReply(`You cannot start an IDEA after the game has started.`);
			if (game.phase !== 'locked' && game.phase !== 'IDEAlocked') return this.errorReply(`You need to close the signups first.`);
			game.ideaInit(user, toId(target));
		},
		ideahelp: [
			`/mafia idea [idea] - starts the IDEA module [idea]. Requires + % @ $ * # & ~, voices can only start for themselves`,
			`/mafia ideareroll - rerolls the IDEA module. Requires host % @ $ * # & ~`,
			`/mafia ideapick [selection], [role] - selects a role`,
			`/mafia ideadiscards - shows the discarded roles`,
		],

		customidea: function (target, room, user) {
			if (!this.can('mute', null, room)) return;
			if (!room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.started) return this.errorReply(`You cannot start an IDEA after the game has started.`);
			if (game.phase !== 'locked' && game.phase !== 'IDEAlocked') return this.errorReply(`You need to close the signups first.`);
			const [options, roles] = Chat.splitFirst(target, '\n');
			if (!options || !roles) return this.parse('/help mafia idea');
			const [choicesStr, ...picks] = options.split(',').map(x => x.trim());
			const choices = parseInt(choicesStr);
			if (!choices || choices <= picks.length) return this.errorReply(`You need to have more choices than picks.`);
			if (picks.some((value, index, arr) => arr.indexOf(value, index + 1) > 0)) return this.errorReply(`Your picks must be unique.`);
			game.customIdeaInit(user, choices, picks, roles);
		},
		customideahelp: [
			`/mafia customidea choices, picks (new line here, shift+enter)`,
			`(comma or newline separated rolelist) - Starts an IDEA module with custom roles. Requires % @ $ # & ~`,
		],
		'!ideapick': true,
		ideapick: function (target, room, user) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (!(user.userid in game.players)) return user.sendTo(targetRoom, '|error|You are not a player in the game.');
			if (game.phase !== 'IDEApicking') return user.sendTo(targetRoom, `|error|The game is not in the IDEA picking phase.`);
			game.ideaPick(user, args);
		},

		'!ideareroll': true,
		ideareroll: function (target, room, user) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			game.ideaDistributeRoles(user);
		},
		idearerollhelp: [`/mafia ideareroll - rerolls the roles for the current IDEA module. Requires host % @ $ * # & ~`],

		ideadiscards: function (target, room, user) {
			if (!room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (!game.IDEA.data) return this.errorReply(`There is no IDEA module in the mafia game.`);
			if (!game.IDEA.discardsHtml) return this.errorReply(`The IDEA module does not have finalised discards yet.`);
			if (!this.runBroadcast()) return;
			this.sendReplyBox(`<details><summary>IDEA discards:</summary>${game.IDEA.discardsHtml}</details>`);
		},

		'!start': true,
		start: function (target, room, user) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			game.start(user);
		},
		starthelp: [`/mafia start - Start the game of mafia. Signups must be closed. Requires host % @ $ * # & ~`],

		'!day': true,
		extend: 'day',
		night: 'day',
		day: function (target, room, user, connection, cmd) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (cmd === 'night') {
				game.night();
			} else {
				let extension = parseInt(toId(args.join('')));
				if (isNaN(extension)) {
					extension = 0;
				} else {
					if (extension < 1) extension = 1;
					if (extension > 10) extension = 10;
				}
				game.day((cmd === 'extend' ? extension : null));
			}
		},
		dayhelp: [
			`/mafia day - Move to the next game day. Requires host % @ $ * # & ~`,
			`/mafia night - Move to the next game night. Requires host % @ $ * # & ~`,
			`/mafia extend (minutes) - Return to the previous game day. If (minutes) is provided, set the deadline for (minutes) minutes. Requires host % @ $ * # & ~`,
		],

		'!lynch': true,
		l: 'lynch',
		lynch: function (target, room, user) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (!this.canTalk(null, targetRoom)) return;
			if (!(user.userid in game.players) && (!(user.userid in game.dead) || !game.dead[user.userid].restless)) return user.sendTo(targetRoom, `|error|You are not in the game of ${game.title}.`);
			game.lynch(user.userid, toId(args.join('')));
		},
		lynchhelp: [`/mafia lynch [player|nolynch] - Vote to lynch the specified player or to not lynch anyone.`],

		'!unlynch': true,
		ul: 'unlynch',
		unl: 'unlynch',
		unnolynch: 'unlynch',
		unlynch: function (target, room, user) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (!this.canTalk(null, targetRoom)) return;
			if (!(user.userid in game.players) && (!(user.userid in game.dead) || !game.dead[user.userid].restless)) return user.sendTo(targetRoom, `|error|You are not in the game of ${targetRoom.game.title}.`);
			game.unlynch(user.userid);
		},
		unlynchhelp: [`/mafia unlynch - Withdraw your lynch vote. Fails if you're not voting to lynch anyone`],

		nl: 'nolynch',
		nolynch: function () {
			this.parse('/mafia lynch nolynch');
		},

		'!selflynch': true,
		enableself: 'selflynch',
		selflynch: function (target, room, user, connection, cmd) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			let action = toId(args.shift());
			if (!action) return this.parse(`/help mafia selflynch`);
			if (this.meansYes(action)) {
				game.setSelfLynch(user, true);
			} else if (this.meansNo(action)) {
				game.setSelfLynch(user, false);
			} else if (action === 'hammer') {
				game.setSelfLynch(user, 'hammer');
			} else {
				return this.parse(`/help mafia selflynch`);
			}
		},
		selflynchhelp: [`/mafia selflynch [on|hammer|off] - Allows players to self lynch themselves either at hammer or anytime. Requires host % @ $ * # & ~`],

		'!kill': true,
		treestump: 'kill',
		spirit: 'kill',
		spiritstump: 'kill',
		kick: 'kill',
		kill: function (target, room, user, connection, cmd) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			const player = game.players[toId(args.join(''))];
			if (!player) return user.sendTo(targetRoom, `|error|"${args.join(',')}" is not a living player.`);
			if (game.phase === 'IDEApicking') return this.errorReply(`You cannot add or remove players while IDEA roles are being picked.`); // needs to be here since eliminate doesn't pass the user
			game.eliminate(player, cmd);
		},
		killhelp: [
			`/mafia kill [player] - Kill a player, eliminating them from the game. Requires host % @ $ * # & ~`,
			`/mafia treestump [player] - Kills a player, but allows them to talk during the day still.`,
			`/mafia spirit [player] - Kills a player, but allows them to vote on the lynch still.`,
			`/mafia spiritstump [player] Kills a player, but allows them to talk during the day, and vote on the lynch.`,
		],

		'!revive': true,
		forceadd: 'revive',
		add: 'revive',
		revive: function (target, room, user, connection, cmd) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (!toId(args.join(''))) return this.parse('/help mafia revive');
			for (const targetUser of args) {
				game.revive(user, toId(targetUser), cmd === 'forceadd');
			}
		},
		revivehelp: [`/mafia revive [player] - Revive a player who died or add a new player to the game. Requires host % @ $ * # & ~`],

		dl: 'deadline',
		deadline: function (target, room, user) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			target = toId(target);
			if (target && game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (target === 'off') {
				return game.setDeadline(0);
			} else {
				const num = parseInt(target);
				if (isNaN(num)) {
					if ((game.hostid === user.userid || game.cohosts.includes(user.userid)) && this.cmdToken === "!") {
						const broadcastMessage = this.message.toLowerCase().replace(/[^a-z0-9\s!,]/g, '');
						if (room.lastBroadcast === broadcastMessage &&
							room.lastBroadcastTime >= Date.now() - 20 * 1000) {
							return this.errorReply("You can't broadcast this because it was just broadcasted.");
						}
						this.broadcasting = true;
						this.broadcastMessage = broadcastMessage;
						this.sendReply('|c|' + this.user.getIdentity(this.room.id) + '|' + this.message);
						room.lastBroadcastTime = Date.now();
						room.lastBroadcast = broadcastMessage;
					}
					if (!this.runBroadcast()) return false;
					if ((game.dlAt - Date.now()) > 0) {
						return this.sendReply(`|raw|<strong>The deadline is in ${Chat.toDurationString(game.dlAt - Date.now()) || '0 seconds'}.</strong>`);
					} else {
						return this.parse(`/help mafia deadline`);
					}
				}
				if (num < 1 || num > 20) return this.errorReply(`The deadline must be between 1 and 20 minutes.`);
				return game.setDeadline(num);
			}
		},
		deadlinehelp: [`/mafia deadline [minutes|off] - Sets or removes the deadline for the game. Cannot be more than 20 minutes.`],

		applylynchmodifier: 'applyhammermodifier',
		applyhammermodifier: function (target, room, user, connection, cmd) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (!game.started) return this.errorReply(`The game has not started yet.`);
			const [player, mod] = target.split(',');
			if (cmd === 'applyhammermodifier') {
				game.applyHammerModifier(user, toId(player), parseInt(mod));
			} else {
				game.applyLynchModifier(user, toId(player), parseInt(mod));
			}
		},
		clearlynchmodifiers: 'clearhammermodifiers',
		clearhammermodifiers: function (target, room, user, connection, cmd) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (!game.started) return this.errorReply(`The game has not started yet.`);
			if (cmd === 'clearhammermodifiers') {
				game.clearHammerModifiers(user);
			} else {
				game.clearLynchModifiers(user);
			}
		},

		hate: 'love',
		unhate: 'love',
		unlove: 'love',
		removelynchmodifier: 'love',
		love: function (target, room, user, connection, cmd) {
			let mod;
			switch (cmd) {
			case 'hate':
				mod = -1;
				break;
			case 'love':
				mod = 1;
				break;
			case 'unhate': case 'unlove': case 'removelynchmodifier':
				mod = 0;
				break;
			}
			this.parse(`/mafia applyhammermodifier ${target}, ${mod}`);
		},
		doublevoter: 'mayor',
		voteless: 'mayor',
		unvoteless: 'mayor',
		unmayor: 'mayor',
		mayor: function (target, room, user, connection, cmd) {
			let mod;
			switch (cmd) {
			case 'doublevoter': case 'mayor':
				mod = 2;
				break;
			case 'voteless':
				mod = 0;
				break;
			case 'unvoteless': case 'unmayor':
				mod = 1;
				break;
			}
			this.parse(`/mafia applylynchmodifier ${target}, ${mod}`);
		},

		shifthammer: 'hammer',
		resethammer: 'hammer',
		hammer: function (target, room, user, connection, cmd) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (!game.started) return this.errorReply(`The game has not started yet.`);
			const hammer = parseInt(target);
			if ((isNaN(hammer) || hammer < 1) && cmd.toLowerCase() !== `resethammer`) return this.errorReply(`${target} is not a valid hammer count.`);
			switch (cmd.toLowerCase()) {
			case 'shifthammer':
				game.shiftHammer(hammer);
				break;
			case 'hammer':
				game.setHammer(hammer);
				break;
			default:
				game.resetHammer();
				break;
			}
		},
		hammerhelp: [
			`/mafia hammer [hammer] - sets the hammer count to [hammer] and resets lynches`,
			`/mafia shifthammer [hammer] - sets the hammer count to [hammer] without resetting lynches`,
			`/mafia resethammer - sets the hammer to the default, resetting lynches`,
		],

		'!enablenl': true,
		disablenl: 'enablenl',
		enablenl: function (target, room, user, connection, cmd) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (cmd === 'enablenl') {
				game.setNoLynch(user, true);
			} else {
				game.setNoLynch(user, false);
			}
		},
		enablenlhelp: [`/mafia [enablenl|disablenl] - Allows or disallows players abstain from lynching. Requires host % @ $ # & ~`],

		lynches: function (target, room, user) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (!game.started) return this.errorReply(`The game of mafia has not started yet.`);
			if ((game.hostid === user.userid || game.cohosts.includes(user.userid)) && this.cmdToken === "!") {
				const broadcastMessage = this.message.toLowerCase().replace(/[^a-z0-9\s!,]/g, '');
				if (room.lastBroadcast === broadcastMessage &&
					room.lastBroadcastTime >= Date.now() - 20 * 1000) {
					return this.errorReply("You can't broadcast this because it was just broadcasted.");
				}
				this.broadcasting = true;
				this.broadcastMessage = broadcastMessage;
				this.sendReply('|c|' + this.user.getIdentity(this.room.id) + '|' + this.message);
				room.lastBroadcastTime = Date.now();
				room.lastBroadcast = broadcastMessage;
			}
			if (!this.runBroadcast()) return false;

			this.sendReplyBox(game.lynchBox());
		},

		pl: 'players',
		players: function (target, room, user) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if ((game.hostid === user.userid || game.cohosts.includes(user.userid)) && this.cmdToken === "!") {
				const broadcastMessage = this.message.toLowerCase().replace(/[^a-z0-9\s!,]/g, '');
				if (room.lastBroadcast === broadcastMessage &&
					room.lastBroadcastTime >= Date.now() - 20 * 1000) {
					return this.errorReply("You can't broadcast this because it was just broadcasted.");
				}
				this.broadcasting = true;
				this.broadcastMessage = broadcastMessage;
				this.sendReply('|c|' + this.user.getIdentity(this.room.id) + '|' + this.message);
				room.lastBroadcastTime = Date.now();
				room.lastBroadcast = broadcastMessage;
			}
			if (!this.runBroadcast()) return false;

			if (this.broadcasting) {
				game.sendPlayerList();
			} else {
				this.sendReplyBox(`Players (${game.playerCount}): ${Object.keys(game.players).map(p => game.players[p].safeName).join(', ')}`);
			}
		},

		originalrolelist: 'rolelist',
		orl: 'rolelist',
		rl: 'rolelist',
		rolelist: function (target, room, user, connection, cmd) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.closedSetup) return this.errorReply(`You cannot show roles in a closed setup.`);
			if (!this.runBroadcast()) return false;
			if (game.IDEA.data) {
				let buf = `<details><summary>IDEA roles:</summary>${game.IDEA.data.roles.join(`<br />`)}</details>`;
				return this.sendReplyBox(buf);
			}
			const showOrl = (['orl', 'originalrolelist'].includes(cmd) || game.noReveal);
			const roleString = (showOrl ? game.originalRoles : game.roles).sort((a, b) => {
				if (a.alignment < b.alignment) return -1;
				if (b.alignment < a.alignment) return 1;
				return 0;
			}).map(role => role.safeName).join(', ');

			this.sendReplyBox(`${showOrl ? `Original Rolelist: ` : `Rolelist: `}${roleString}`);
		},

		playerroles: function (target, room, user) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid)) return this.errorReply(`Only the host can view roles.`);
			if (!game.started) return this.errorReply(`The game has not started.`);
			const players = [...Object.values(game.players), ...Object.values(game.dead)];
			this.sendReplyBox(players.map(p => `${p.safeName}: ${p.role ? p.role.safeName : 'No role'}`).join('<br/>'));
		},

		spectate: 'view',
		view: function (target, room, user, connection) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			if (!this.runBroadcast()) return;
			if (this.broadcasting) return this.sendReplyBox(`<button name="joinRoom" value="view-mafia-${room.id}" class="button"><strong>Spectate the game</strong></button>`);
			return this.parse(`/join view-mafia-${room.id}`);
		},

		'!mafsub': true,
		forcesub: 'mafsub',
		sub: 'mafsub', // Typescript doesn't like "sub" as the command name for some reason, so this is a hack to get around that.
		mafsub: function (target, room, user, connection, cmd) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			let action = toId(args.shift());
			switch (action) {
			case 'in':
				if (user.userid in game.players) {
					// Check if they have requested to be subbed out.
					if (!game.requestedSub.includes(user.userid)) return user.sendTo(targetRoom, `|error|You have not requested to be subbed out.`);
					game.requestedSub.splice(game.requestedSub.indexOf(user.userid), 1);
					user.sendTo(room, `|error|You have cancelled your request to sub out.`);
					game.players[user.userid].updateHtmlRoom();
				} else {
					if (!this.canTalk(null, targetRoom)) return;
					if (game.subs.includes(user.userid)) return user.sendTo(targetRoom, `|error|You are already on the sub list.`);
					if (game.played.includes(user.userid)) return user.sendTo(targetRoom, `|error|You cannot sub back into the game.`);
					const canJoin = game.canJoin(user, true);
					if (canJoin) return user.sendTo(targetRoom, `|error|${canJoin}`);
					game.subs.push(user.userid);
					game.nextSub();
					// Update spectator's view
					this.parse(`/join view-mafia-${targetRoom.id}`);
				}
				break;
			case 'out':
				if (user.userid in game.players) {
					if (game.requestedSub.includes(user.userid)) return user.sendTo(targetRoom, `|error|You have already requested to be subbed out.`);
					game.requestedSub.push(user.userid);
					game.players[user.userid].updateHtmlRoom();
					game.nextSub();
				} else {
					if (game.hostid === user.userid || game.cohosts.includes(user.userid)) return user.sendTo(targetRoom, `|error|The host cannot sub out of the game.`);
					if (!game.subs.includes(user.userid)) return user.sendTo(targetRoom, `|error|You are not on the sub list.`);
					game.subs.splice(game.subs.indexOf(user.userid), 1);
					// Update spectator's view
					this.parse(`/join view-mafia-${targetRoom.id}`);
				}
				break;
			case 'next':
				if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
				let toSub = args.shift();
				if (!(toId(toSub) in game.players)) return user.sendTo(targetRoom, `|error|${toSub} is not in the game.`);
				if (!game.subs.length) {
					if (game.hostRequestedSub.indexOf(toId(toSub)) !== -1) return user.sendTo(targetRoom, `|error|${toSub} is already on the list to be subbed out.`);
					user.sendTo(targetRoom, `|error|There are no subs to replace ${toSub}, they will be subbed if a sub is available before they speak next.`);
					game.hostRequestedSub.unshift(toId(toSub));
				} else {
					game.nextSub(toId(toSub));
				}
				break;
			case 'remove':
				if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
				const toRemove = toId(args.shift());
				const toRemoveIndex = game.subs.indexOf(toRemove);
				if (toRemoveIndex === -1) return user.sendTo(room, `|error|${toRemove} is not on the sub list.`);
				game.subs.splice(toRemoveIndex, 1);
				user.sendTo(room, `${toRemove} has been removed from the sublist`);
				break;
			case 'unrequest':
				if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
				const toUnrequest = toId(args.shift());
				const userIndex = game.requestedSub.indexOf(toUnrequest);
				const hostIndex = game.hostRequestedSub.indexOf(toUnrequest);
				if (userIndex < 0 && hostIndex < 0) return user.sendTo(room, `|error|${toUnrequest} is not requesting a sub.`);
				if (userIndex > -1) {
					game.requestedSub.splice(userIndex, 1);
					user.sendTo(room, `${toUnrequest}'s sub request has been removed.`);
				}
				if (hostIndex > -1) {
					game.hostRequestedSub.splice(userIndex, 1);
					user.sendTo(room, `${toUnrequest} has been removed from the host sublist.`);
				}
				break;
			default:
				if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
				const toSubOut = action;
				const toSubIn = toId(args.shift());
				if (!(toSubOut in game.players)) return user.sendTo(targetRoom, `|error|${toSubOut} is not in the game.`);

				const targetUser = Users(toSubIn);
				if (!targetUser) return user.sendTo(targetRoom, `|error|The user "${toSubIn}" was not found.`);
				const canJoin = game.canJoin(targetUser, false, cmd === 'forcesub');
				if (canJoin) return user.sendTo(targetRoom, `|error|${canJoin}`);
				if (game.subs.includes(targetUser.userid)) game.subs.splice(game.subs.indexOf(targetUser.userid), 1);
				if (game.hostRequestedSub.includes(toSubOut)) game.hostRequestedSub.splice(game.hostRequestedSub.indexOf(toSubOut), 1);
				if (game.requestedSub.includes(toSubOut)) game.requestedSub.splice(game.requestedSub.indexOf(toSubOut), 1);
				game.sub(toSubOut, toSubIn);
			}
		},
		subhelp: [
			`/mafia sub in - Request to sub into the game, or cancel a request to sub out.`,
			`/mafia sub out - Request to sub out of the game, or cancel a request to sub in.`,
			`/mafia sub next, [player] - Forcibly sub [player] out of the game. Requires host % @ $ * # & ~`,
			`/mafia sub remove, [user] - Remove [user] from the sublist. Requres host % @ $ * # & ~`,
			`/mafia sub unrequest, [player] - Remove's a player's request to sub out of the game. Requires host % @ $ * # & ~`,
			`/mafia sub [player], [user] - Forcibly sub [player] for [user]. Requires host % @ $ * # & ~`,
		],

		"!autosub": true,
		autosub: function (target, room, user) {
			const args = target.split(',');
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(args[0]));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			} else {
				args.shift();
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('mute', null, room)) return;
			if (this.meansYes(toId(args.join('')))) {
				if (game.autoSub) return user.sendTo(targetRoom, `|error|Automatic subbing of players is already enabled.`);
				game.autoSub = true;
				user.sendTo(targetRoom, `Automatic subbing of players has been enabled.`);
				game.nextSub();
			} else if (this.meansNo(toId(args.join('')))) {
				if (!game.autoSub) return user.sendTo(targetRoom, `|error|Automatic subbing of players is already disabled.`);
				game.autoSub = false;
				user.sendTo(targetRoom, `Automatic subbing of players has been disabled.`);
			} else {
				return this.parse(`/help mafia autosub`);
			}
		},
		autosubhelp: [`/mafia autosub [yes|no] - Sets if players will automatically sub out if a user is on the sublist. Requires host % @ $ * # & ~`],

		cohost: 'subhost',
		forcecohost: 'subhost',
		forcesubhost: 'subhost',
		subhost: function (target, room, user, connection, cmd) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (!this.canTalk()) return;
			if (!target) return this.parse(`/help mafia ${cmd}`);
			if (!this.can('mute', null, room)) return false;
			this.splitTarget(target, false);
			let targetUser = this.targetUser;
			if (!targetUser || !targetUser.connected) return this.errorReply(`The user "${this.targetUsername}" was not found.`);
			if (!room.users[targetUser.userid]) return this.errorReply(`${targetUser.name} is not in this room, and cannot be hosted.`);
			if (game.hostid === targetUser.userid) return this.errorReply(`${targetUser.name} is already the host.`);
			if (game.cohosts.includes(targetUser.userid)) return this.errorReply(`${targetUser.name} is already a cohost.`);
			if (targetUser.userid in game.players) return this.errorReply(`The host cannot be ingame.`);
			if (targetUser.userid in game.dead) {
				if (!cmd.includes('force')) return this.errorReply(`${targetUser.name} could potentially be revived. To continue anyway, use /mafia force${cmd} ${target}.`);
				if (game.dead[targetUser.userid].lynching) game.unlynch(targetUser.userid);
				game.dead[targetUser.userid].destroy();
				delete game.dead[targetUser.userid];
			}
			if (cmd.includes('cohost')) {
				game.cohosts.push(targetUser.userid);
				game.sendRoom(`${Chat.escapeHTML(targetUser.name)} has been added as a cohost by ${Chat.escapeHTML(user.name)}`, {declare: true});
				// @ts-ignore
				targetUser.send(`>view-mafia-${room.id}\n|init|html\n|${Chat.pages.mafia([room.id], targetUser)}`);
				this.modlog('MAFIACOHOST', targetUser, null, {noalts: true, noip: true});
			} else {
				const oldHostid = game.hostid;
				const oldHost = Users(game.hostid);
				if (oldHost) oldHost.send(`>view-mafia-${room.id}\n|deinit`);
				if (game.subs.includes(targetUser.userid)) game.subs.splice(game.subs.indexOf(targetUser.userid), 1);
				const queueIndex = hostQueue.indexOf(targetUser.userid);
				if (queueIndex > -1) hostQueue.splice(queueIndex, 1);
				game.host = Chat.escapeHTML(targetUser.name);
				game.hostid = targetUser.userid;
				game.played.push(targetUser.userid);
				// @ts-ignore
				targetUser.send(`>view-mafia-${room.id}\n|init|html\n${Chat.pages.mafia([room.id], targetUser)}`);
				game.sendRoom(`${Chat.escapeHTML(targetUser.name)} has been substituted as the new host, replacing ${oldHostid}.`, {declare: true});
				this.modlog('MAFIASUBHOST', targetUser, `replacing ${oldHostid}`, {noalts: true, noip: true});
			}
		},
		subhosthelp: [`/mafia subhost [user] - Substitues the user as the new game host.`],
		cohosthelp: [`/mafia cohost [user] - Adds the user as a cohost. Cohosts can talk during the game, as well as perform host actions.`],

		uncohost: 'removecohost',
		removecohost: function (target, room, user) {
			if (!room || !room.game || room.game.gameid !== 'mafia') return this.errorReply(`There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (room.game);
			if (!this.canTalk()) return;
			if (!target) return this.parse('/help mafia subhost');
			if (!this.can('mute', null, room)) return false;
			target = toId(target);

			const cohostIndex = game.cohosts.indexOf(target);
			if (cohostIndex < 0) {
				if (game.hostid === target) return this.errorReply(`${target} is the host, not a cohost. Use /mafia subhost to replace them.`);
				return this.errorReply(`${target} is not a cohost.`);
			}
			game.cohosts.splice(cohostIndex, 1);
			game.sendRoom(`${target} was removed as a cohost by ${Chat.escapeHTML(user.name)}`, {declare: true});
			this.modlog('MAFIAUNCOHOST', target, null, {noalts: true, noip: true});
		},

		'!end': true,
		end: function (target, room, user) {
			let targetRoom /** @type {ChatRoom?} */ = (Rooms(target));
			if (!targetRoom || targetRoom.type !== 'chat' || !targetRoom.users[user.userid]) {
				if (!room || room.type !== 'chat') return this.errorReply(`This command is only meant to be used in chat rooms.`);
				targetRoom = room;
			}
			if (!targetRoom.game || targetRoom.game.gameid !== 'mafia') return user.sendTo(targetRoom, `|error|There is no game of mafia running in this room.`);
			const game = /** @type {MafiaTracker} */ (targetRoom.game);
			if (game.hostid !== user.userid && !game.cohosts.includes(user.userid) && !this.can('broadcast', null, room)) return;
			game.end();
			this.room = targetRoom;
			this.modlog('MAFIAEND', null);
		},
		endhelp: [`/mafia end - End the current game of mafia. Requires host + % @ $ * # & ~`],

		role: 'data',
		modifier: 'data',
		alignment: 'data',
		theme: 'data',
		dt: 'data',
		data: function (target, room, user, connection, cmd) {
			if (!room || !room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (cmd === 'role' && !target) {
				// Support /mafia role showing your current role if you're in a game
				const game = /** @type {MafiaTracker} */ (room.game);
				if (!game || game.id !== 'mafia') return this.errorReply(`There is no game of mafia running in this room. If you meant to display information about a role, use /mafia role [role name]`);
				if (!(user.userid in game.players)) return this.errorReply(`You are not in the game of ${game.title}.`);
				const role = game.players[user.userid].role;
				if (!role) return this.errorReply(`You do not have a role yet.`);
				return this.sendReplyBox(`Your role is: ${role.safeName}`);
			}
			if (!this.runBroadcast()) return;
			if (!target) return this.parse(`/help mafia data`);

			/** @type {{[k: string]: string}} */
			const types = {alignment: 'alignments', role: 'roles', modifier: 'modifiers', theme: 'themes'};
			let id = target.split(' ').map(toId).join('_');
			let result = null;
			let dataType = cmd;
			if (cmd in types) {
				let type = /** @type {'alignments' | 'roles' | 'modifiers' | 'themes'} */ (types[cmd]);
				let data = MafiaData[type];
				if (!data) return this.errorReply(`"${type}" is not a valid search area.`); // Should never happen
				if (!data[id]) return this.errorReply(`"${target} is not a valid ${cmd}."`);
				result = data[id];
				if (typeof result === 'string') result = data[result];
			} else {
				// Search all
				for (let i in types) {
					let type = /** @type {'alignments' | 'roles' | 'modifiers' | 'themes'} */ (types[i]);
					let data = MafiaData[type];
					if (!data) continue; // Should never happen
					if (!data[id]) continue;
					result = data[id];
					if (typeof result === 'string') result = data[result];
					dataType = i;
					break;
				}
				if (!result) return this.errorReply(`"${target}" is not a valid mafia alignment, role, modifier, or theme.`);
			}
			let buf = `<h3${result.color ? ' style="color: ' + result.color + '"' : ``}>${result.name}</h3><b>Type</b>: ${dataType}<br/>`;
			if (dataType === 'theme') {
				buf += `<b>Description</b>: ${result.desc}<br/><details><summary class="button" style="font-weight: bold; display: inline-block">Setups:</summary>`;
				for (let i in result) {
					if (isNaN(parseInt(i))) continue;
					buf += `${i}: `;
					/** @type {{[k: string]: number}} */
					let count = {};
					let roles = [];
					for (const role of result[i].split(',').map((/** @type {string} */x) => x.trim())) {
						count[role] = count[role] ? count[role] + 1 : 1;
					}
					for (const role in count) {
						roles.push(count[role] > 1 ? `${count[role]}x ${role}` : role);
					}
					buf += `${roles.join(', ')}<br/>`;
				}
			} else {
				buf += `${result.memo.join('<br/>')}`;
			}
			return this.sendReplyBox(buf);
		},
		datahelp: [`/mafia data [alignment|role|modifier|theme] - Get information on a mafia alignment, role, modifier, or theme.`],

		winfaction: 'win',
		win: function (target, room, user, connection, cmd) {
			if (!room || !room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (room.id !== 'mafia') return this.errorReply(`This command can only be used in the Mafia room.`);
			if (cmd === 'winfaction' && (!room.game || room.game.gameid !== 'mafia')) return this.errorReply(`There is no game of mafia running in the room`);
			if (!this.can('mute', null, room)) return;
			const args = target.split(',');
			let points = parseInt(args[0]);
			if (isNaN(points)) {
				points = 10;
			} else {
				if (points > 100 || points < -100) return this.errorReply(`You cannot give or take more than 100 points at a time.`);
				// shift out the point count
				args.shift();
			}
			if (!args.length) return this.parse('/help mafia win');
			const month = new Date().toLocaleString("en-us", {month: "numeric", year: "numeric"});
			if (!logs.leaderboard[month]) logs.leaderboard[month] = {};

			let toGiveTo = [];
			let buf = `${points} were awarded to: `;
			if (cmd === 'winfaction') {
				const game = /** @type {MafiaTracker} */ (room.game);
				for (let faction of args) {
					faction = toId(faction);
					let inFaction = [];
					for (const user of [...Object.values(game.players), ...Object.values(game.dead)]) {
						if (user.role && toId(user.role.alignment) === faction) {
							toGiveTo.push(user.userid);
							inFaction.push(user.userid);
						}
					}
					if (inFaction.length) buf += ` the ${faction} faction: ${inFaction.join(', ')};`;
				}
			} else {
				toGiveTo = args;
				buf += toGiveTo.join(', ');
			}
			if (!toGiveTo.length) return this.parse('/help mafia win');
			let gavePoints = false;
			for (let u of toGiveTo) {
				u = toId(u);
				if (!u) continue;
				if (!gavePoints) gavePoints = true;
				if (!logs.leaderboard[month][u]) logs.leaderboard[month][u] = 0;
				logs.leaderboard[month][u] += points;
				if (logs.leaderboard[month][u] === 0) delete logs.leaderboard[month][u];
			}
			if (!gavePoints) return this.parse('/help mafia win');
			writeFile(LOGS_FILE, logs);
			this.modlog(`MAFIAPOINTS`, null, `${points} points were awarded to ${Chat.toListString(toGiveTo)}`);
			room.add(buf).update();
		},
		winhelp: [
			`/mafia win (points), [user1], [user2], [user3], ... - Award the specified users points to the mafia leaderboard for this month. The amount of points can be negative to take points. Defaults to 10 points.`,
			`/mafia winfaction (points), [faction] - Award the specified points to all the players in the given faction.`,
		],

		unmvp: 'mvp',
		mvp: function (target, room, user, connection, cmd) {
			if (!room || !room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (room.id !== 'mafia') return this.errorReply(`This command can only be used in the Mafia room.`);
			if (!this.can('mute', null, room)) return;
			const args = target.split(',');
			if (!args.length) return this.parse('/help mafia mvp');
			const month = new Date().toLocaleString("en-us", {month: "numeric", year: "numeric"});
			if (!logs.mvps[month]) logs.mvps[month] = {};
			if (!logs.leaderboard[month]) logs.leaderboard[month] = {};
			let gavePoints = false;
			for (let u of args) {
				u = toId(u);
				if (!u) continue;
				if (!gavePoints) gavePoints = true;
				if (!logs.leaderboard[month][u]) logs.leaderboard[month][u] = 0;
				if (!logs.mvps[month][u]) logs.mvps[month][u] = 0;
				if (cmd === 'unmvp') {
					logs.mvps[month][u]--;
					logs.leaderboard[month][u] -= 10;
					if (logs.mvps[month][u] === 0) delete logs.mvps[month][u];
					if (logs.leaderboard[month][u] === 0) delete logs.leaderboard[month][u];
				} else {
					logs.mvps[month][u]++;
					logs.leaderboard[month][u] += 10;
				}
			}
			if (!gavePoints) return this.parse('/help mafia mvp');
			writeFile(LOGS_FILE, logs);
			this.modlog(`MAFIA${cmd.toUpperCase()}`, null, `MVP and 10 points were ${cmd === 'unmvp' ? 'taken from' : 'awarded to'} ${Chat.toListString(args)}`);
			room.add(`MVP and 10 points were ${cmd === 'unmvp' ? 'taken from' : 'awarded to'}: ${Chat.toListString(args)}`).update();
		},
		mvphelp: [
			`/mafia mvp [user1], [user2], ... - Gives a MVP point and 10 leaderboard points to the users specified.`,
			`/mafia unmvp [user1], [user2], ... - Takes away a MVP point and 10 leaderboard points from the users specified.`,
		],

		hostlogs: 'leaderboard',
		playlogs: 'leaderboard',
		leaverlogs: 'leaderboard',
		mvpladder: 'leaderboard',
		lb: 'leaderboard',
		leaderboard: function (target, room, user, connection, cmd) {
			if (!room || !room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (room.id !== 'mafia') return this.errorReply(`This command can only be used in the Mafia room.`);
			if (['hostlogs', 'playlogs', 'leaverlogs'].includes(cmd)) {
				if (!this.can('mute', null, room)) return;
			} else {
				// Deny broadcasting host/playlogs
				if (!this.runBroadcast()) return;
			}
			if (cmd === 'lb') cmd = 'leaderboard';
			if (this.broadcasting) return this.sendReplyBox(`<button name="joinRoom" value="view-mafialadder-${cmd}" class="button"><strong>${cmd}</strong></button>`);
			return this.parse(`/join view-mafialadder-${cmd}`);
		},
		leaderboardhelp: [
			`/mafia [leaderboard|mvpladder] - View the leaderboard or MVP ladder for the current or last month.`,
			`/mafia [hostlost|playlogs|leaverlogs] - View the host, play, or leaver logs for the current or last month. Requires % @ $ * # & ~`,
		],

		unhostban: 'hostban',
		hostban: function (target, room, user, connection, cmd) {
			if (!room || !room.mafiaEnabled) return this.errorReply(`Mafia is disabled for this room.`);
			if (room.id !== 'mafia') return this.errorReply(`This command can only be used in the Mafia room.`);

			const duration = parseInt(this.splitTarget(target, false));
			if (!this.targetUser) return this.errorReply(`User ${target} not found.`);
			if (!this.can('mute', this.targetUser, room)) return false;

			const isUnban = (cmd.startsWith('un'));
			if (isHostBanned(toId(this.targetUsername)) === !isUnban) return this.errorReply(`${this.targetUsername} is ${isUnban ? 'not' : 'already'} banned from hosting games.`);

			if (isUnban) {
				delete hostBans[toId(this.targetUsername)];
				this.modlog(`MAFIAUNHOSTBAN`, this.targetUser);
			} else {
				if (isNaN(duration) || duration < 1) return this.parse('/help mafia hostban');
				if (duration > 7) return this.errorReply(`Bans cannot be longer than 7 days.`);

				hostBans[toId(this.targetUsername)] = Date.now() + 1000 * 60 * 60 * 24 * duration;
				this.modlog(`MAFIAHOSTBAN`, this.targetUser, `for ${duration} days.`);
				const queueIndex = hostQueue.indexOf(toId(this.targetUsername));
				if (queueIndex > -1) hostQueue.splice(queueIndex, 1);
			}
			writeFile(BANS_FILE, hostBans);
			room.add(`${this.targetUsername} was ${isUnban ? 'un' : ''}banned from hosting games${!isUnban ? ` for ${duration} days` : ''} by ${user.name}.`).update();
		},
		hostbanhelp: [
			`/mafia hostban [user], [duration] - Ban a user from hosting games for [duration] days. Requires % @ $ * # & ~`,
			`/mafia unhostban [user] - Unbans a user from hosting games. Requires % @ $ * # & ~`,
		],

		disable: function (target, room, user) {
			if (!room || !this.can('gamemanagement', null, room)) return;
			if (!room.mafiaEnabled) {
				return this.errorReply("Mafia is already disabled.");
			}
			delete room.mafiaEnabled;
			if (room.chatRoomData) {
				delete room.chatRoomData.mafiaEnabled;
				Rooms.global.writeChatRoomData();
			}
			this.modlog('MAFIADISABLE', null);
			return this.sendReply("Mafia has been disabled for this room.");
		},
		disablehelp: [`/mafia disable - Disables mafia in this room. Requires # & ~`],

		enable: function (target, room, user) {
			if (!room || !this.can('gamemanagement', null, room)) return;
			if (room.mafiaEnabled) {
				return this.errorReply("Mafia is already enabled.");
			}
			room.mafiaEnabled = true;
			if (room.chatRoomData) {
				room.chatRoomData.mafiaEnabled = true;
				Rooms.global.writeChatRoomData();
			}
			this.modlog('MAFIAENABLE', null);
			return this.sendReply("Mafia has been enabled for this room.");
		},
		enablehelp: [`/mafia enable - Enables mafia in this room. Requires # & ~`],
	},
	mafiahelp: function (target, room, user) {
		if (!this.runBroadcast()) return;
		let buf = `<strong>Commands for the Mafia Plugin</strong><br/>Most commands are used through buttons in the game screen.<br/><br/>`;
		buf += `<details><summary class="button">General Commands</summary>`;
		buf += [
			`<br/><strong>General Commands for the Mafia Plugin</strong>:<br/>`,
			`/mafia host [user] - Create a game of Mafia with [user] as the host. Roomvoices can only host themselves. Requires + % @ $ * # & ~`,
			`/mafia nexthost - Host the next user in the host queue. Only works in the Mafia Room. Requires + % @ $ * # & ~`,
			`/mafia forcehost [user] - Bypass the host queue and host [user]. Only works in the Mafia Room. Requires % @ $ * # & ~`,
			`/mafia sub in - Request to sub into the game, or cancel a request to sub out.`,
			`/mafia sub out - Request to sub out of the game, or cancel a request to sub in.`,
			`/mafia spectate - Spectate the game of mafia.`,
			`/mafia ideadiscards - Shows the discarded roles list for an IDEA module.`,
			`/mafia lynches - Display the current lynch count, and whos lynching who.`,
			`/mafia players - Display the current list of players, will highlight players.`,
			`/mafia [rl|orl] - Display the role list or the original role list for the current game.`,
			`/mafia data [alignment|role|modifier|theme] - Get information on a mafia alignment, role, modifier, or theme.`,
			`/mafia subhost [user] - Substitues the user as the new game host. Requires % @ $ * # & ~`,
			`/mafia cohost [user] - Adds the user as a cohost. Cohosts can talk during the game, as well as perform host actions. Requires % @ $ * # & ~`,
			`/mafia uncohost [user] - Remove [user]'s cohost status. Requires % @ $ * # & ~`,
			`/mafia disable - Disables mafia in this room. Requires # & ~`,
			`/mafia enable - Enables mafia in this room. Requires # & ~`,
		].join('<br/>');
		buf += `</details><details><summary class="button">Player Commands</summary>`;
		buf += [
			`<br/><strong>Commands that players can use</strong>:<br/>`,
			`/mafia join - Join the game.`,
			`/mafia leave - Leave the game. Can only be done while signups are open.`,
			`/mafia lynch [player|nolynch] - Vote to lynch the specified player or to not lynch anyone.`,
			`/mafia unlynch - Withdraw your lynch vote. Fails if you're not voting to lynch anyone`,
			`/mafia deadline - View the deadline for the current game.`,
			`/mafia sub in - Request to sub into the game, or cancel a request to sub out.`,
			`/mafia sub out - Request to sub out of the game, or cancel a request to sub in.`,
			`/mafia ideapick [selection], [role] - Selects a role from an IDEA module`,
		].join('<br/>');
		buf += `</details><details><summary class="button">Host Commands</summary>`;
		buf += [
			`<br/><strong>Commands for game hosts and Cohosts to use</strong>:<br/>`,
			`/mafia playercap [cap|none]- Limit the number of players able to join the game. Player cap cannot be more than 20 or less than 2. Requires: host % @ $ # & ~`,
			`/mafia close - Closes signups for the current game. Requires: host % @ $ * # & ~`,
			`/mafia closedsetup [on|off] - Sets if the game is a closed setup. Closed setups don't show the role list to players. Requires host % @ $ * # & ~`,
			`/mafia reveal [on|off] - Sets if roles reveal on death or not. Requires host % @ $ * # & ~`,
			`/mafia selflynch [on|hammer|off] - Allows players to self lynch themselves either at hammer or anytime. Requires host % @ $ * # & ~`,
			`/mafia [enablenl|disablenl] - Allows or disallows players abstain from lynching. Requires host % @ $ # & ~`,
			`/mafia setroles [comma seperated roles] - Set the roles for a game of mafia. You need to provide one role per player. Requires host % @ $ # & ~`,
			`/mafia forcesetroles [comma seperated roles] - Forcibly set the roles for a game of mafia. No role PM information or alignment will be set. Requires host % @ $ # & ~`,
			`/mafia idea [idea] - starts an IDEA module. Requires + % @ $ * # & ~, voices can only start for themselves`,
			`/mafia ideareroll - rerolls the current IDEA module. Requires host % @ $ * # & ~`,
			`/mafia customidea choices, picks (new line here, shift+enter)`,
			`(comma or newline separated rolelist) - Starts an IDEA module with custom roles. Requires % @ $ # & ~`,
			`/mafia start - Start the game of mafia. Signups must be closed. Requires host % @ $ * # & ~`,
			`/mafia day - Move to the next game day. Requires host % @ $ * # & ~`,
			`/mafia night - Move to the next game night. Requires host % @ $ * # & ~`,
			`/mafia extend (minutes) - Return to the previous game day. If (minutes) is provided, set the deadline for (minutes) minutes. Requires host % @ $ * # & ~`,
			`/mafia kill [player] - Kill a player, eliminating them from the game. Requires host % @ $ * # & ~`,
			`/mafia treestump [player] - Kills a player, but allows them to talk during the day still. Requires host % @ $ * # & ~`,
			`/mafia spirit [player] - Kills a player, but allows them to vote on the lynch still. Requires host % @ $ * # & ~`,
			`/mafia spiritstump [player] - Kills a player, but allows them to talk during the day, and vote on the lynch. Requires host % @ $ * # & ~`,
			`/mafia kick [player] - Kicks a player from the game without revealing their role. Requires host % @ $ * # & ~`,
			`/mafia revive [player] - Revive a player who died or add a new player to the game. Requires host % @ $ * # & ~`,
			`/mafia deadline [minutes|off] - Sets or removes the deadline for the game. Cannot be more than 20 minutes.`,
			`/mafia sub next, [player] - Forcibly sub [player] out of the game. Requires host % @ $ * # & ~`,
			`/mafia sub remove, [user] - Forcibly remove [user] from the sublist. Requres host % @ $ * # & ~`,
			`/mafia sub unrequest, [player] - Remove's a player's request to sub out of the game. Requires host % @ $ * # & ~`,
			`/mafia sub [player], [user] - Forcibly sub [player] for [user]. Requires host % @ $ * # & ~`,
			`/mafia autosub [yes|no] - Sets if players will automatically sub out if a user is on the sublist. Defaults to yes. Requires host % @ $ * # & ~`,
			`/mafia [love|hate] [player] - Makes it take 1 more (love) or less (hate) lynch to hammer [player]. Requires host % @ $ * # & ~`,
			`/mafia [unlove|unhate] [player] - Removes loved or hated status from [player]. Requires host % @ $ * # & ~`,
			`/mafia [mayor|voteless] [player] - Makes [player]'s' lynch worth 2 votes (mayor) or makes [player]'s lynch worth 0 votes (voteless). Requires host % @ $ * # & ~`,
			`/mafia [unmayor|unvoteless] [player] - Removes mayor or voteless status from [player]. Requires host % @ $ * # & ~`,
			`/mafia hammer [hammer] - sets the hammer count to [hammer] and resets lynches`,
			`/mafia shifthammer [hammer] - sets the hammer count to [hammer] without resetting lynches`,
			`/mafia resethammer - sets the hammer to the default, resetting lynches`,
			`/mafia playerroles - View all the player's roles in chat. Requires host`,
			`/mafia end - End the current game of mafia. Requires host % @ $ * # & ~`,
		].join('<br/>');
		buf += `</details><details><summary class="button">Mafia Room Specific Commands</summary>`;
		buf += [
			`<br/><strong>Commands that are only useable in the Mafia Room</strong>:<br/>`,
			`/mafia queue add, [user] - Adds the user to the host queue. Requires % @ $ * # & ~.`,
			`/mafia queue remove, [user] - Removes the user from the queue. You can remove yourself regardless of rank. Requires % @ $ * # & ~.`,
			`/mafia queue - Shows the list of users who are in queue to host.`,
			`/mafia win (points) [user1], [user2], [user3], ... - Award the specified users points to the mafia leaderboard for this month. The amount of points can be negative to take points. Defaults to 10 points.`,
			`/mafia winfaction (points), [faction] - Award the specified points to all the players in the given faction. Requires % @ $ * # & ~`,
			`/mafia mvp [user1], [user2], ... - Gives a MVP point and 10 leaderboard points to the users specified.`,
			`/mafia unmvp [user1], [user2], ... - Takes away a MVP point and 10 leaderboard points from the users specified.`,
			`/mafia [leaderboard|mvpladder] - View the leaderboard or MVP ladder for the current or last month.`,
			`/mafia [hostlost|playlogs] - View the host logs or play logs for the current or last month. Requires % @ $ * # & ~`,
			`/mafia hostban [user], [duration] - Ban a user from hosting games for [duration] days. Requires % @ $ * # & ~`,
			`/mafia unhostban [user] - Unbans a user from hosting games. Requires % @ $ * # & ~`,
		].join('<br/>');
		buf += `</details>`;

		return this.sendReplyBox(buf);
	},
};

module.exports = {
	commands,
	pages,
};

process.nextTick(() => {
	Chat.multiLinePattern.register('/mafia customidea');
});
